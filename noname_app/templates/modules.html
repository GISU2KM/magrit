<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta  content="text/html; charset=utf-8"  http-equiv="content-type">
    <meta  http-equiv="X-UA-Compatible"  content="IE=edge">
    <meta  name="viewport"  content="width=device-width, initial-scale=1, user-scalable=yes">
    <title> GeoPossum </title>
    <link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
    <link href="/static/css/discretization.css" rel="stylesheet" type="text/css">
    <link href="/static/css/jquery.qtip.min.css" rel="stylesheet" type="text/css">
    <link href="/static/css/style.css" rel="stylesheet"  type="text/css">
    <link href="/static/css/datatables.min.css" rel="stylesheet" type="text/css">
    <link href="/static/css/context-menu.css" rel="stylesheet" type="text/css">
    <link href="/static/css/sweetalert2.min.css" rel="stylesheet" type="text/css">
    <script  src="/static/js/lib/d3.v3.min.js"></script>
    <script  src="/static/js/lib/topojson.v1.min.js"></script>
    <script  src="/static/js/lib/d3.geo.projection.js"></script>
    <script  src="/static/js/lib/polyhedron.js"></script>
    <script  src="/static/js/lib/jquery-2.2.1.min.js"></script>
    <script  src="/static/js/lib/jquery-ui.min.js"></script>
    <script  src="/static/js/lib/geostats.min.js"></script>
    <script  src="/static/js/lib/colorbrewer.v1.min.js"></script>
    <script  src="/static/js/lib/q.js"></script>
    <script  src="/static/js/lib/i18next.min.js"></script>
    <script  src="/static/js/lib/i18nextXHRBackend.min.js"></script>
    <script  src="/static/js/lib/jquery.qtip.min.js"></script>
    <script  src="/static/js/lib/sweetalert2.min.js"></script>
    <script  src="/static/js/lib/datatables.min.js"></script>
    <script  src="/static/js/txt_annotation.js"></script>
    <script  src="/static/js/lib/context-menu.js"></script>
    <script  src="/static/js/interface.js"></script>
    <script  src="/static/js/layers_style_popup.js"></script>
    <script  src="/static/js/discretization_panel.js"></script>
    <script  src="/static/js/colors_helpers.js"></script>
    <script  src="/static/js/function.js"></script>
    <script  src="/static/js/legend.js"></script>
    <script  src="/static/js/join_popup.js"></script>
    <script  src="/static/js/colors_helpers.js"></script>
  </head>
  <body>
      <div id="header">
        <p style="display:inline;margin-left:10px;"><i><a href="/">GeoPossum</a></i></p>
        <p id="rgt" class="header_options"><a href="https://github.com/riatelab/noname-stuff/">Sources</a>  <a href="">Documentation</a>&emsp;</p></div>
      <div id="menu"></div>
  	 <div id="map"></div>
      <div id="user_id" style="display:none">{{ user_id }}</div>
      <a id="downloadAnchorElem" style="display:none"></a>
<script>
"use strict";

function make_eye_button(state){
    if(state == "open"){
        let eye_open = document.createElement("img");
        eye_open.setAttribute("src", "/static/img/b/eye_open.svg");
        eye_open.setAttribute("class", "active_button")
        eye_open.setAttribute("id", "eye_open");
        eye_open.setAttribute("width", 17);
        eye_open.setAttribute("height", 17);
        eye_open.setAttribute("alt", "Visible");
        return eye_open;
    } else if (state == "closed"){
        let eye_closed = document.createElement("img");
        eye_closed.setAttribute("src", "/static/img/b/eye_closed.svg");
        eye_closed.setAttribute("class", "active_button");
        eye_closed.setAttribute("id", "eye_closed");
        eye_closed.setAttribute("width", 17);
        eye_closed.setAttribute("height", 17);
        eye_closed.setAttribute("alt", "Not visible");
        return eye_closed;
    }
}

function make_ico_choice(){
    let list_fun_ico = ['icon_label.png',
                        'icon_choroprop.png',
                        'icon_grid.png',
                        'icon_typo.png',
                        'icon_prop.png',
                        'icon_flow.png',
                        'icon_cartogram.png',
                        'icon_mta.png',
                        'icon_choro.png',
                        'icon_smooth.png',
                        'icon_symbol.png',
                        'icon_discont.png'];
    let function_panel = section2_pre.append("p")
                            .style("text-align", "center")
                            .style("margin-top", "1px")
                            .style("margin-bottom", "1px");
    for(let i = 0, len_i = list_fun_ico.length; i < len_i; i++){
        let ico_name = list_fun_ico[i],
            func_name = ico_name.split('.')[0].split("_")[1],
            func_desc = get_menu_option(func_name).desc;
        function_panel.append("img")
            .attr("title", func_desc)
            .attr("src", ["/static/img/func_icons/", ico_name].join(''))
            .style("margin", "1px")
            .on("click", function(){
                current_functionnality = get_menu_option(func_name);
                let make_menu = eval(current_functionnality.menu_factory);
                window.fields_handler = eval(current_functionnality.fields_handler);
                // Replace the title of the section without touching the triangle icon from the menu:
                let selec_title = document.getElementById("accordion2").querySelector("h3");
                selec_title.innerHTML = selec_title.innerHTML.replace(selec_title.innerText, current_functionnality.title);
                clean_menu_function();
                make_menu();

                if(targeted_layer_added){
                    let target_layer = Object.getOwnPropertyNames(user_data)[0];
                    fields_handler.fill(target_layer);
                }
                if(func_name == "flow" && joined_dataset){
                    fields_handler.fill();
                }
                switch_accordion_section("accordion2_pre", "accordion2");
            });
    }
}

var w = Math.round(window.innerWidth - 360),
    h = window.innerHeight - 75;
    //h = Math.round(window.innerHeight / 1.24);

var proj = d3.geo.naturalEarth().scale(1).translate([0,0]);

var path = d3.geo.path().projection(proj).pointRadius(4),
    t = proj.translate(),
    s = proj.scale(),
    current_proj_name = "Natural Earth",
    available_projections = new Map(),
    zoom = d3.behavior.zoom().on("zoom", zoom_without_redraw),
    sample_no_values = new Set(["Sphere", "Graticule", "Simplified_land_polygons"]);

/*
A bunch of global variable, storing oftently reused informations :
    - user_date[layer_name] : will be an Array of Objects containing data for each features of the targeted layer
            (+ the joined features if a join is done)
    - result_data[layer_name] : the same but for any eventual result layers (like Stewart, gridded, etc.)
    - joined_dataset : the joined dataset (read with d3.csv is pushed in the first slot of this array)
    - field_join_map : an array containg mapping between index of geom layer and index of ext. dataset
    - current_layers : the main object describing **all** the layers on the map (incunding detailed, ie by features, styling properties if needed)
    - last_params : an object to fill with the last user selected paremeter after "valid" button of
            the targeted functionnality has been pushed
*/

var user_data = new Object(),
    result_data = new Object(),
    joined_dataset = [],
    field_join_map  = [],
    target_layer_on_add = false,
    targeted_layer_added = false,
    current_layers = new Object(),
    last_params = new Object(),
    dataset_name = undefined,
    join_button = null,
    canvas_rotation_value = undefined,
    map_div = d3.select("#map"),
    current_functionnality = undefined;

// The "map" (so actually the `map` variable is a reference to the main `svg` element on which we are drawing)
var map = map_div.style("width", w+"px").style("height", h+"px")
            .append("svg")
                .attr("id", "svg_map")
                .attr("width", w)
                .attr("height", h)
                .call(zoom);

// A bunch of references to the buttons used in the layer manager
// and some mapping to theses reference according to the type of geometry :
var button_style = ' <img src="/static/img/High-contrast-edit-clear.svg" class="style_button" width="17" height="17" alt="submit"/>',
    button_trash = ' <img src="/static/img/Trash_font_awesome.svg" id="trash_button" width="17" height="17" alt="submit"/>',
    button_legend = ' <img src="/static/img/qgis_legend.svg" id="legend_button" width="17" height="17" alt="submit"/>',
    button_zoom_fit = ' <img src="/static/img/Inkscape_icons_zoom_fit_page.svg" id="zoom_fit_button" width="17" height="17" alt="submit"/></button>',
    button_type = new Map([
        ["Point", '<img src="/static/img/type_geom/dot.svg" class="ico_type" width="17" height="17" alt="Point"/>'],
        ["Line", '<img src="/static/img/type_geom/line.svg" class="ico_type" width="17" height="17" alt="Line"/>'],
        ["Polygon", '<img src="/static/img/type_geom/poly.svg" class="ico_type" width="17" height="17" alt="Polygon"/>']
        ]);

var button_result_type = new Map([
        ["flow", '<img src="/static/img/type_geom/layer_flow.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["symbol", '<img src="/static/img/type_geom/layer_symbol.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["grid", '<img src="/static/img/type_geom/layer_grid.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["MTA", '<img src="/static/img/type_geom/layer_mta.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["propchoro", '<img src="/static/img/type_geom/layer_propchoro.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["typo", '<img src="/static/img/type_geom/layer_typo.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["discont", '<img src="/static/img/type_geom/layer_disc.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["cartogram", '<img src="/static/img/type_geom/layer_cartogram.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["label", '<img src="/static/img/type_geom/layer_label.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["choro", '<img src="/static/img/type_geom/layer_choro.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["smooth", '<img src="/static/img/type_geom/layer_smooth.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["prop", '<img src="/static/img/type_geom/layer_prop.svg" class="ico_type" width="17" height="17" alt="Polygon"/>']
        ]);

var eye_open0 = '<img src="/static/img/b/eye_open.svg" class="active_button" id="eye_open"  width="17" height="17" alt="Visible"/>';

// Reference to the sys run button already in two requested sizes are they are called many times :
var sys_run_button = '<img src="/static/img/High-contrast-system-run.svg" width="22" height="22" alt="submit"/>',
    sys_run_button_t2 = '<img src="/static/img/High-contrast-system-run.svg" class="style_target_layer" width="16" height="16" alt="Layer_rendering" style="float:right;margin-top:4px;"/>'


current_layers["Simplified_land_polygons"] = {"type": "Polygon", "n_features":125, "stroke-width-const": 0.3, "fill_color": {single: "#d3d3d3"}}

//////////////////////////////////////////////////////////////////////////////
// Set-up the menu
//
// Some of these variables (menu, dv1, section3, dv3, dv4, background, p, const_options, etc.)
// are not needed anymore after being used here so they are put into curly braces and declared with `let`
// to ensure their garbage collection:
//////////////////////////////////////////////////////////////////////////////
{
    let menu = d3.select("#menu"),
        accordion1 = menu.append("div").attr("id","accordion1").attr("class", "accordion"),
        accordion2_pre = menu.append("div").attr("id","accordion2_pre").attr("class", "accordion"),
        accordion2 = menu.append("div").attr("id","accordion2").attr("class", "accordion"),
        accordion3 = menu.append("div").attr("id","accordion3").attr("class", "accordion"),
        accordion4 = menu.append("div").attr("id","accordion4").attr("class", "accordion"),
        accordion5 = menu.append("div").attr("id","accordion5").attr("class", "accordion");

    accordion1.append("h3").html(i18next.t("Add your data"));
    accordion2_pre.append("h3").html(i18next.t("Choose a function"));
    accordion2.append("h3").html(i18next.t("Function options"));
    accordion3.append("h3").html(i18next.t("Layers"));
    accordion4.append("h3").html(i18next.t("Basemap configuration"));
    accordion5.append("h3").html(i18next.t("Projection options"));

    var section1 =  accordion1.append("div").attr("id","section1")
                        .attr("data-tooltip", i18next.t("Drop a GeoJSON, TopoJSON, ziped shapefile project or KML file here or add manually a layer by clicking here")),
        section2_pre =  accordion2_pre.append("div").attr("id","section2_pre").style("padding", "0"),
        section2 =  accordion2.append("div").attr("id","section2");
    accordion3.append("div")
        .attr({"id": "section3",
               "data-tooltip": "Drop new layout layer or click to browse locally and add one.<br> Supported type : shapefile (must be provided with .dbf and .prj files) GeoJSON, TopoJSON and KML"}),
    accordion4.append("div").attr("id","section4");
    accordion5.append("div").attr("id","section5");

    let dv1 = section1.append("div"),
        dv11 = dv1.append("div").style("width", "auto");

    dv11.append("img")
        .attr({"id": "img_in_geom", "class": "user_panel", "src": "/static/img/b/addgeom.png", "width": "26", "height": "26",  "alt": "Geometry layer"})
        .style("cursor", "pointer")
        .on('click',  click_button_add_layer);

    dv11.append("p")
        .attr({id: "input_geom", class: "user_panel"})
        .style({display: "inline", cursor: "pointer", "margin-left": "5px", "vertical-align": "super"})
        //.html('<b>"Add geometry layer <i>(or drop it)</i></b>')
        .html("<b>" + i18next.t("Add geometry layer") + " <i>" + i18next.t("(or drop it)") + "</i></b>")
        .on('click',  click_button_add_layer);

    let dv12 = dv1.append("div");
    dv12.append("img")
        .attr({"id": "img_data_ext", "class": "user_panel", "src": "/static/img/b/addtabular.png", "width": "26", "height": "26",  "alt": "Additional dataset"})
        .style("cursor", "pointer")
        .on('click',  click_button_add_layer);
    dv12.append("p")
        .attr({"id": "data_ext", "class": "user_panel"})
        .style({display: "inline", cursor: "pointer", "margin-left": "5px", "vertical-align": "super"})
        //.html('<b>Add additional dataset <i>(or drop it)</i></b>')
        .html("<b>" + i18next.t("Add additional dataset") + " <i>" + i18next.t("(or drop it)") + "</i></b>")
        .on('click',  click_button_add_layer);

    let div_sample = dv1.append("div").attr("id", "sample_zone");
    div_sample.append("img")
        .attr({"id": "sample_button", "class": "user_panel", "src": "/static/img/b/addsample.png", "width": "26", "height": "26",  "alt": "Sample layers"})
        .style("cursor", "pointer")
        .on('click', add_sample_layer);
    div_sample.append("span")
        .attr({"id": "sample_link", "class": "user_panel"})
        .style({display: "inline", cursor: "pointer", "margin-left": "5px", "vertical-align": "super"})
        //.html("<b>Select available sample dataset</b>")
        .html("<b>" + i18next.t("Select available sample dataset") + "</b>")
        .on('click', add_sample_layer);

    dv1.append("p")
        .attr("id", "join_section")
        .style({"text-align": "center", "margin-top": "2px"})
        .html("");
    dv1.append("p")
        .attr("id", "browse_section")
        .attr("align", "center")
        .html("")
        .append("button")
        .attr({id: "browse_button", class: "button_st3", disabled: true})
        .style("font-size", "12px")
        //.html("Explore your table(s)")
        .html(i18next.t("Explore your table(s)"))
        .on("click", function(){  boxExplore.create();  });

    make_ico_choice();

    section2.append("p")
            .style("font-size", "18px")
            .html(i18next.t("No choosen functionnality"));
            //.html("No choosen functionnality ...");

    let section3 = d3.select("#section3");

    var layer_list = section3.append("div").append("ul").attr("id", "sortable").attr("class", "layer_list");

    let dv3 = section3.append("div")
                    .style("padding-top", "10px").html('');

    dv3.append("img")
        .style("float", "right").style("border-radius", "10%").style("margin", "2.5px")
        .attr("src", "/static/img/b/addsample.png")
        .on('click', add_layout_layers);
    dv3.append("img")
        .attr("src", "/static/img/b/addgeom.png")
        .style("float", "right").style("border-radius", "10%").style("margin", "2.5px")
        .on("click", click_button_add_layer);

    let section4 = d3.select("#section4");
    let dv4 = section4.append("p").attr("class", "form-item").style("margin", "auto");
    dv4.append("div")
            .style({float: "left", width: "50%", "text-align": "center"})
            //.html("<b>Canvas width (px)</b><br>")
            .html("<b>" + i18next.t("Canvas width") + " (px)</b><br>")
            .insert("input").style("width", "60px")
            .attr({id: "input-width", type: "number", value: w, width: "55px"})
            .on("change", function(){canvas_mod_size([this.value,null])});
    dv4.append("div")
            .style({float: "right", width: "50%", "text-align": "center"})
            //.html("<b>Canvas height (px)</b><br>")
            .html("<b>" + i18next.t("Canvas height") + " (px)</b><br>")
            .insert("input").style("width", "60px")
            .attr({id: "input-height", type: "number", "value": h})
            .on("change", function(){canvas_mod_size([null,this.value])});
    dv4.append("p")
            .style({"text-align": "center","margin": "5px 0px 0px 50px", "display": "inline-block"})
            //.html("Map title<br>")
            .html(i18next.t("Map title") + "<br>")
            .insert("input").attr("id", "title")
            .on("keyup", function(){handle_title(this.value);});
    dv4.insert("_img")
            .style("display", "inline").style("top", "4px")
            .html(sys_run_button.replace("submit", "Title properties"))
            .on("click", handle_title_properties);
    dv4.append("p").style("text-align", "center").html(i18next.t("Background color"))
            .insert("input").style("margin-left", "15px")
            .attr({type: "color", id: "bg_color", value: "#ffffff"})
            .on("change", function(){handle_bg_color(this.value);});

    dv4.append("p")
            //.html(sys_run_button + " Add layout features (arrow, scale, etc.)")
            .html(sys_run_button + " " + i18next.t("Add layout features"))
            .on("click", select_layout_features);

    let section5 = d3.select("#section5");
    let dv5 = section5.append("p").attr("class", "form-item");
    dv5.insert('label-item').html("<b>" + i18next.t("Projection") + " </b><br>");

    section5.append("div").html(i18next.t("Canvas rotation"));
    section5.append("input")
            .attr("type", "range")
            .attr("id","form_rotate")
            .attr("value",0).attr("min",0)
            .attr("max",360).attr("step",1)
            .on("input", function(){rotate_global(this.value)});

    var rotation_param = section5.append("div").html(i18next.t("Projection center (λ-axis rotation)"))
    rotation_param.append("input")
            .attr("type", "range")
            .attr("id","form_projection_center")
            .attr("value", 0).attr("min", -180)
            .attr("max", 180).attr("step", 0.5)
            .on("input", function(){handle_proj_center_button([this.value, null, null])});

    section5.append("div").insert("button")
            .attr("id","reset_center_rotation")
            .attr("class", "button_st4")
            //.text("Reset center/zooming/rotation")
            .text(i18next.t("Reset center/zooming/rotation"))
            .on("click", function(){
                zoom.scale(0.5).translate([400, 250]);
                zoom_without_redraw();
                let proj_params = get_approx_zoom(h, w);
                proj.scale(proj_params.approx_scale).translate(proj_params.approx_translate);
                document.getElementById('form_projection_center').value = 0;
                document.getElementById('form_rotate').value = 0;
                proj.rotate([0,,]);
                reproj_symbol_layer();
                rotate_global(0);
            });

    let background = map.append("g")
                        .attr({id: "Simplified_land_polygons", class: "layer"})
                        .style({"stroke-width": "0.3px"});

    d3.json("/static/data_sample/simplified_land_polygons.topojson", function ready(error, json) {
        background.selectAll('.subunit')
                  .data(topojson.feature(json, json.objects.simplified_land_polygons).features)
                  .enter()
                  .append('path')
                  .attr("d", path)
                  .style({stroke: "rgb(0,0,0)", fill: "lightgrey", "stroke-opacity": 0.0, "fill-opacity": 0.75});
        map.selectAll("path").attr("d", path);
        scale_to_lyr("Simplified_land_polygons");
        center_map("Simplified_land_polygons");
        zoom_without_redraw();
    });

    let p = dv5.append("select")
                .attr("id","form_projection")
                .style("align", "center")
                .on("change", function(){
                    change_projection(this.value);
                    let layer_name = Object.getOwnPropertyNames(user_data)[0] || Object.getOwnPropertyNames(result_data)[0] || null;
                    if(layer_name){
                        center_map(layer_name);
                        zoom_without_redraw();
                    }
                });
    d3.json("/static/json/projections.json", function(json) {
       json.forEach(function(d) {
            available_projections.set(d.name, d.projection);
            p.append("option").text(d.name).attr("value", d.projection);
           });
    });

    let const_options = d3.select(".header_options").append("div").attr("id", "const_options").style("display", "inline")
    const_options.append("button").attr("class", "const_buttons")
                  .attr("title", "Export your composition")
                  .html('<img src="/static/img/Wikiversity-Mooc-Icon-Download_modif.svg" width="20" height="20" alt="Export"/>')
                  .style("margin-top", "none")
                  .on("click", handle_export);

    const_options.append("button").attr("class", "const_buttons")
                  .attr("title", "Export / Load your map preferences")
                  .html('<img src="/static/img/High-contrast-system-run.svg" width="20" height="20" alt="export_load_preferences"/>')
                  .style("margin-top", "none")
                  .on("click", function(){
                        if(document.getElementById("menu_pref"))
                            document.getElementById("menu_pref").remove();
                        else {
                            let actions = [
                                {"name": i18next.t("Save your preferences"), "callback": save_map_template},
                                {"name": i18next.t("Load a preference JSON"), "callback": load_map_template}
                                ];
                            let menu = document.createElement("div");
                            menu.style.top = "30px";
                            menu.style.right = "35px";
                            menu.className = "context-menu";
                            menu.id = "menu_pref";
                            let list_elems = document.createElement("ul");
                            menu.appendChild(list_elems);
                            for (let i = 0; i < actions.length; i++) {
                                let item = document.createElement("li");
                                list_elems.appendChild(item);
                                item.setAttribute("data-index",i);
                                let name = document.createElement("span");
                                name.className = "context-menu-item-name";
                                name.style.color = "#000";
                                name.textContent = actions[i].name;
                                item.appendChild(name);
                                item.onclick = function(){
                                    actions[i].callback();
                                    menu.remove();
                                }
                            }
                            document.querySelector("body").appendChild(menu);
                        }
                    });

    const_options.append("button").attr("class", "const_buttons")
                  .attr("title", "Help")
                  .html('<img src="/static/img/High-contrast-help-browser.svg" width="20" height="20" alt="export_load_preferences"/>')
                  .style("margin-top", "none")
                  .on("click", function(){
                      swal({
                          title: "Emergency help !",
                          text: "Write something to be searched in the documentation :",
                          input: "text",
                          showCancelButton: true,
                          closeOnConfirm: false,
                          animation: "slide-from-top",
                          inputPlaceholder: "Choropleth, Discretization, Cartogram, Export, Projection"
                       }).then(inputValue => {
                              swal("Nice!", "You wrote: " + inputValue, "success");
                        })
                    });

    // Zoom-in, Zoom-out, Info, Hand-Move and RectZoom buttons (on the top of the map) :
    let lm = map_div
                .append("div")
                .attr("class", "light-menu")
                .style({position:"absolute", right:"0px", bottom: "0px"});

    let lm_buttons = [
        {id: "zoom_out", title: "Zoom out", class: "zoom_button", html: "-"},
        {id: "zoom_in", title: "Zoom in", class: "zoom_button", html: "+"},
        {id: "info_button", title: "Feature information", class: "info_button", html: "i"},
        {id: "hand_button", title: "Use the cursor to move on the map (default behavior)", class: "hand_button active", html: '<img src="/static/img/Closed_Hand_thenounproject_blank.svg" width="18" height="18" alt="Hand_closed"/>'},
        {id: "brush_zoom_button", class: "brush_zoom_button", title: "Zoom on selection", html: '<img src="/static/img/Inkscape_icons_zoom_fit_selection_blank.svg" width="18" height="18" alt="Zoom_select"/>'}
    ];

    let selec = lm.selectAll("input")
        .data(lm_buttons).enter()
        .append('p').style("margin", "auto")
            .insert("button")
            .attr("class", d => d.class)
            .attr("title", d => d.title)
            .attr("id", d => d.id)
            .html(d => d.html);

    // Trigger actions when buttons are clicked and set-up the initial view :
    d3.selectAll(".zoom_button").on("click", zoomClick);
    document.getElementById("info_button").onclick = displayInfoOnMove;
    document.getElementById("hand_button").onclick = handle_click_hand;
    document.getElementById("hand_button").style = "box-shadow: 2px 2px 1px black inset;";
    let brush_rect = handle_click_zoom_select(); // Pretty ugly closure to remember the last click-on-the-map behavior
    document.getElementById("brush_zoom_button").onclick = brush_rect;
}

// Already append the div for displaying information on features,
// setting it currently unactive until it will be requested :
d3.select("body").append("div")
              .attr("id", "info_features")
              .classed("active", false)
              .html("");

create_li_layer_elem("Simplified_land_polygons", null, "Polygon", "sample");
prepare_drop_section();

/////////////////////////////////////////////////////////////////////////////
// JQuery menu, tooltips and progress bar related functions :
//////////////////////////////////////////////////////////////////////////////

// Set-up all the accordions :
$(".accordion").accordion({ collapsible: true, active: false, heightStyle: "#map" });

// Start with the first always open :
$("#accordion1").accordion("option", "active", 0);

// Close the functionnality options accordion when the user intend to choose another function :
$("#accordion2_pre").on("accordionbeforeactivate", function(){
//$("#accordion2_pre").on("accordionbeforeactivate", function(event, ui){
 //   if(ui.newHeader.length) $("#accordion2").accordion({active: false})
    let section2_accordion = document.getElementById("accordion2").firstChild;
    if(section2_accordion.getAttribute("aria-expanded") == "true")
        section2_accordion.dispatchEvent(new Event("click"));
    });

// Close the "choose functionnality" accordion (when one is choosed) to display functionnality options :

// Compute the total size occuped by the menu in order to close some section to avoid go further than the page height :
$(".accordion").on("accordionactivate", function(event, ui){
        if(!(ui.newPanel) || ui.newPanel.length == 0 )
            return ;
        let last_opened = ui.newPanel[0].parentElement.id;
        let opened = [];
        let accordions = document.querySelectorAll(".accordion");
        let new_size = 33; // Use the real header size instead of 33
        for(let i = 0; i < accordions.length ; i++){
            new_size = new_size + accordions[i].getBoundingClientRect().height;
            if(accordions[i].firstChild.getAttribute("aria-expanded") == "true")
                opened.push(accordions[i].id);
        }
        opened.splice(opened.indexOf(last_opened), 1);
        if(new_size > window.innerHeight
                && opened.indexOf("accordion1") > -1
                && last_opened != "accordion1"){
            new_size = new_size - accordions[0].getBoundingClientRect().height;
            opened.splice(opened.indexOf("accordion1"), 1);
            $("#accordion1").accordion("option", "active", 1);
        }
        if(new_size > window.innerHeight){
            for(let i = opened.length - 1; i > 0; --i){
                let acc = document.getElementById(opened[i]);
                new_size = new_size - acc.getBoundingClientRect().height;
                $("#" + opened[i]).accordion("option", "active", 1);
                opened.pop();
            }
        }
    });

function up_legend(){
    let legend_features = svg_map.querySelectorAll('.legend');
    for(let i = 0; i < legend_features.length; i++){
        svg_map.appendChild(legend_features[i], null);
    }
}

// Set up the widget allowing to sort layers :
$( "#sortable" ).sortable({
    placeholder: "ui-state-highlight",
    update: function(a){
      // Set the layer order on the map in concordance with the user changes
      // in the layer manager with a pretty rusty sorting algorythm
      // trying to match the requested order from the actual order
      // (currently havent been tested on a really large number of layers)
      let at_end = null;
      if(document.getElementById("info_features").className == "active"){
        displayInfoOnMove();
        at_end = true;
      }
      let desired_order = [],
          actual_order = [],
          layers = svg_map.querySelectorAll(".layer");

      for(let i=0, len_i = a.target.childNodes.length; i < len_i; i++){
          let n = a.target.childNodes[i].getAttribute("layer_name");
          desired_order[i] = n;
          actual_order[i] = layers[i].id;
      }
      for(let i = 0, len = desired_order.length; i < len; i++){
          let lyr1 = document.getElementById(desired_order[i]),
              lyr2 = document.getElementById(desired_order[i+1]) || document.getElementById(desired_order[i]);
          svg_map.insertBefore(lyr2, lyr1);
      }
     if(at_end) displayInfoOnMove();
     }
  });
$( "#sortable" ).disableSelection();

// Display a progress bar during the ajaxRequest
// (can be unset locally by using the `"global": false` param when making an ajax request)
$(document).ajaxStart(function() {
        var bg = document.createElement('div');
        bg.id = 'overlay';
        var prog_bar = map_div.append("div")
                         .style({position: "absolute",top: "-20px", left: (w/4)+"px", "text-align": "center", "color": "black", "z-index": 2})
                         .attr("id", "progressbar")
                         .html('<img src="/static/img/ajax-loader.gif" style="width:' + (w/3) + 'px"/><br>' + i18next.t('Loading results') + ' ...');
        document.body.appendChild(bg);
    }).ajaxComplete(function() {
        document.getElementById("progressbar").remove();
        document.getElementById("overlay").remove();
});

// bind the mains tooltips
$("#section1[data-tooltip!='']").qtip({
    content: { attr: "data-tooltip" },
    style: { classes: 'qtip-youtube qtip-section1' },
    position: { my: 'center left', at: 'center right', target: this }
})

$("#section3[data-tooltip!='']").qtip({
    content: { attr: "data-tooltip" },
    style: { classes: 'qtip-youtube qtip-section3' },
    position: { my: 'center left', at: 'center right', target: this }
})

////////////////
// To sort:
////////////////

// To bind the set of small buttons (trash icon, paint icon, active/deactive visibility, info tooltip, etc..)
// which are on each feature representing a layer in the layer manager
// (the function is called each time that a new feature is put in this layer manager)
function binds_layers_buttons(layer_name){
    if(layer_name != undefined){
        let sortable_li_elem = d3.select("#sortable").select("." + layer_name);
        sortable_li_elem.select("#trash_button").on("click", function(){ remove_layer(layer_name); });
        sortable_li_elem.select(".active_button").on("click", function(){ handle_active_layer(layer_name); });
        sortable_li_elem.select("#zoom_fit_button").on("click", function(){
            center_map(layer_name);
            zoom_without_redraw();
        });
        sortable_li_elem.select(".style_button").on("click", function(){
            handle_click_layer(layer_name);
        });
        sortable_li_elem.select(".style_target_layer").on("click", function(){
            handle_click_layer(layer_name)
        });
        sortable_li_elem.select("#legend_button").on("click", function(){
            handle_legend(layer_name);
        });
    } else {
        let selec = d3.select('#sortable');
        selec.selectAll("#trash_button").on("click", remove_layer);
        selec.selectAll(".active_button").on("click", function(){
            handle_active_layer(this.parentElement.parentElement.getAttribute("layer_name"));
        });
        selec.selectAll("#zoom_fit_button").on("click", function(){
            center_map(this.parentElement.parentElement.getAttribute("layer_name"));
            zoom_without_redraw();
        });
        selec.selectAll(".style_button").on("click", function(){
            handle_click_layer(this.parentElement.parentElement.getAttribute("layer_name"))
        });
        selec.selectAll(".style_target_layer").on("click", function(){
            handle_click_layer(this.parentElement.parentElement.getAttribute("layer_name"))
        });
        selec.selectAll("#legend_button").on("click", function(){
            handle_legend(this.parentElement.parentElement.getAttribute("layer_name"))
        });
    }
    $("[layer-tooltip!='']").qtip({
        content: { attr: "layer-tooltip" },
        style: { classes: 'qtip-rounded qtip-light qtip_layer'},
        events: {
            show: function(){ $('.qtip.qtip-section3').qtip("hide") },
            hide: function(){ $('.qtip.qtip-section3').qtip("show") }
        }
    });
}

// Function to display information on the top layer (in the layer manager)
// it will only works on layers appearing in blue in the layer manager
// (ie. the targeted layer and result(s?) layer(s?))
function displayInfoOnMove(){
    var info_features = d3.select("#info_features");
    if(info_features.classed("active")){
        d3.select(".info_button").style('box-shadow', null);
        map.selectAll("path").on("mouseover", null);
        map.selectAll("circle").on("mouseover", null);
        map.selectAll("rect").on("mouseover", null);
        info_features.classed("active", false);
        info_features.node().innerHTML = "";
        info_features.style({});
        document.getElementById("map").style.cursor="";
    } else {
        var nb_layer = map.selectAll(".layer")[0].length,
            top_layer = map.selectAll(".layer")[0][nb_layer-1].id;

        let id_top_layer = "#" + top_layer,
            symbol = current_layers[top_layer].symbol;

        d3.select(".info_button").style('box-shadow', 'inset 2px 2px 1px black');
        if(symbol){
            let ref_layer_name = current_layers[top_layer].ref_layer_name;
            map.select(id_top_layer).selectAll(symbol).on("mouseover", function(d,i){
                let ref_id = current_layers[top_layer].features_order ? current_layers[top_layer].features_order[i][0] : +i;
                let txt_info = ["<h3>", top_layer, "</h3><br><i>Feature ",
                                ref_id + 1, "/", current_layers[ref_layer_name].n_features, "</i><br>"];
                let properties = user_data[ref_layer_name][ref_id];
                Object.getOwnPropertyNames(properties).forEach(function(el, i){
                    txt_info.push("<br><b>"+el+"</b> : "+properties[el]);
                    });
                info_features.node().innerHTML = txt_info.join('');
                });
        } else {
            symbol = "path"
            map.select(id_top_layer).selectAll("path").on("mouseover", function(d,i){
                let txt_info = ["<h3>", top_layer, "</h3><br><i>Feature ",
                                i, "/", current_layers[top_layer].n_features, "</i><br>"];
                Object.getOwnPropertyNames(d.properties).forEach(function(el, i){
                    txt_info.push("<br><b>"+el+"</b> : "+d.properties[el]);
                    });
                info_features.node().innerHTML = txt_info.join('');
                });
        }
        map.select(id_top_layer).selectAll(symbol).on("mouseout", function(){
                info_features.node().innerHTML = ""; });
        info_features.classed("active", true);
        document.getElementById("map").style.cursor="help";
    }
}

function reproj(){
  proj.translate([t[0], t[1]]).scale(s);
  map.selectAll("path").attr("d", path);
  reproj_symbol_layer();
}

function reproj_symbol_layer(){
  for(let lyr_name in current_layers){
    if(current_layers[lyr_name].renderer
        && current_layers[lyr_name].renderer.indexOf('PropSymbol') > -1){
      let ref_layer_name = current_layers[lyr_name].ref_layer_name,
          features_order = current_layers[lyr_name].features_order,
          symbol = current_layers[lyr_name].symbol,
          new_coords = new Array();
      map.select("#" + ref_layer_name)
            .selectAll("path")
            .each((d,i) => {
                new_coords.push(path.centroid(d))
            });
      let ord = features_order.map(obj => obj[0]);
      for(let i = 0; i < ord.length; i++)
        features_order[i][2] = new_coords[ord[i]];

      if(symbol == "circle")
          map.select("#"+lyr_name)
                .selectAll(symbol)
                .attr("cx", (d,i) => features_order[i][2][0])
                .attr("cy", (d,i) => features_order[i][2][1])
                .attr("r", (d,i) => features_order[i][1]);
      else if (symbol == "rect")
          map.select("#"+lyr_name)
                .selectAll(symbol)
                .attr("x", (d,i) => features_order[i][2][0] - features_order[i][1] / 2)
                .attr("y", (d,i) => features_order[i][2][1] - features_order[i][1] / 2)
                .attr("height", (d,i) => features_order[i][1])
                .attr("width", (d,i) => features_order[i][1]);
    }
  }
}

// Convenience function to make a confirm dialog returning a defered promise
// which can be used like `myConfirmDialog("Confirm", "ok", "cancel").then(function(confirmed){if(confirmed){ ... }})
var make_confirm_dialog = function(html_content, text_ok, text_cancel, title, class_box, width, height, top){
    html_content = html_content || "";
    text_ok = text_ok || "Ok";
    text_cancel = text_cancel || "Cancel";
    title = title || "Confirm ...";
    class_box = class_box || "dialogBox";
    var deferred = Q.defer();
    d3.select("body").append("div")
        .attr("id", "dialog").attr("class", class_box)
        .attr("title", title).html(html_content);

    $( "#dialog" ).dialog({
        position: top ? { my: "center", at: "top" } : undefined, width: width, height: height, modal:true,
        buttons:[
           {
            text: text_ok,
            click: function(){ deferred.resolve(true); $(this).dialog("close"); }
                },
           {
            text: text_cancel,
            click: function(){ $(this).dialog("close"); $(this).remove(); }
           }],
        close: function(event, ui){
                $(this).dialog("destroy").remove();
                if(deferred.promise.isPending())
                    deferred.resolve(false);
            }
      });
    return deferred.promise;
};

// Wrapper to obtain confirmation before actually removing a layer :
function remove_layer(name){
    name = name || this.parentElement.parentElement.getAttribute("layer_name");
    swal({
        title: "Confirm ?",
        text: ["Remove layer '", name, "?"].join(''),
        type: "warning",
        showCancelButton: true,
        confirmButtonColor: "#DD6B55",
        confirmButtonText: "Delete!",
        closeOnConfirm: false
    }).then(() => { remove_layer_cleanup(name); },
            () => { null; }
    );    // ^^^^^^^^^^^^ Do nothing on cancel, but this avoid having an "uncaught exeption (cancel)" comming in the console if nothing is set here
}

function remove_ext_dataset(){
    swal({
        title: "Confirm ?",
        text: ["Remove external data ?"].join(''),
        type: "warning",
        showCancelButton: true,
        confirmButtonColor: "#DD6B55",
        confirmButtonText: "Delete!",
        closeOnConfirm: true
    }).then(() =>
        {
            field_join_map = new Array();
            joined_dataset = new Array();
            dataset_name = undefined;
            let ext_dataset_img = document.getElementById("img_data_ext");
            ext_dataset_img.setAttribute("src", "/static/img/b/addtabular.svg");
            ext_dataset_img.setAttribute("alt", "Additional dataset");
            ext_dataset_img.style.cursor = "pointer";
            ext_dataset_img.onclick = click_button_add_layer;
            let data_ext_txt = document.getElementById("data_ext");
            data_ext_txt.innerHTML = "<b>Add additional dataset <i>(or drop it)</i></b>";
            data_ext_txt.onclick = click_button_add_layer;
            document.getElementById("remove_dataset").remove();
            document.getElementById("join_section").innerHTML = "";
            document.getElementById('sample_zone').style.display = null;
            $("#data_ext").qtip("destroy");
        }, () => { null; }
    );
}

// Do some clean-up when a layer is removed
// Most of the job is to do when it's the targeted layer which is removed in
// order to restore functionnalities to their initial states
function remove_layer_cleanup(name){
     let g_lyr_name = "#"+name;

     // Making some clean-up regarding the result layer :
    if(current_layers[name].is_result){
        d3.selectAll([".lgdf_", name].join('')).remove();
        if(result_data.hasOwnProperty(name))
            delete result_data[name];
        if(current_layers[name].hasOwnProperty("key_name"))
            send_remove_server(name);
    }

    // Remove the layer from the map and from the layer manager :
    map.select(g_lyr_name).remove();
    //document.querySelector('#sortable .' + name).remove()
    d3.select("#sortable").select('.'+name).remove();

    // Reset the panel displaying info on the targeted layer if she"s the one to be removed :
    if(current_layers[name].targeted){
        // Updating the top of the menu (section 1) :
        $("#input_geom").qtip("destroy");
        d3.select("#img_in_geom")
            .attr({"id": "img_in_geom", "class": "user_panel", "src": "/static/img/b/addgeom.png", "width": "24", "height": "24",  "alt": "Geometry layer"})
            .on('click',  click_button_add_layer);
        d3.select("#input_geom").html("<b>Add geometry layer <i>(or drop it)</i></b>")
            .on('click', click_button_add_layer);
        document.getElementById("remove_target").remove();
        // Unfiling the fields related to the targeted functionnality:
        if(current_functionnality)
            fields_handler.unfill()

        // Update some global variables :
        field_join_map = [];
        user_data = new Object();
        targeted_layer_added = false;

        // Redisplay the bottom of the section 1 in the menu allowing user to select a sample layer :
        document.getElementById('sample_zone').style.display = null;

        // Restore the state of the bottom of the section 1 :
        if(d3.select("#join_button").node() != null)
            //valid_join_check_display();
            d3.select("#join_section").html("");

        // If after this removal there isn't nor a targeted layer neither an external dataset :
        if(joined_dataset.length == 0)
            document.getElementById("browse_button").disabled = true;
    }

    // There is probably better ways in JS to delete the object,
    // but in order to make it explicit that we are removing it :
    delete current_layers[name];
    swal(i18next.t("Deleted") + "!", [i18next.t("Layer"), name, i18next.t("has been removed")].join(' '), i18next.t("success"));
}

function load_map_template(){
    let input_button = d3.select(document.createElement('input'))
                    .attr("type", "file").attr("name", "file")
                    .attr("enctype", "text/json")
                    .on('change', function(){ prepareReading(d3.event) });

    let prepareReading = function(event){
        let file = event.target.files[0],
            reader = new FileReader();
        reader.onloadend = function(){ apply_user_preferences(reader.result); }
        reader.readAsText(file);
    }

    input_button.node().dispatchEvent(new MouseEvent("click"))
}

// Change color of the background (ie the parent "svg" element on the top of which group of elements have been added)
function handle_bg_color(color){
    map.style("background-color", color);
}

function handle_click_hand(){
    var hb = d3.select('.hand_button');
    if(hb.classed("active")){
        hb.style('box-shadow', "none").classed("active", false);
        zoom.on("zoom", null);
    } else {
        hb.style('box-shadow', 'inset 2px 2px 1px black').classed("active", true);
        zoom.on("zoom", zoom_without_redraw);
        map.on("mousemove.zoomRect", null).on("mouseup.zoomRect", null);
    }
}

// Trying to handle zooming using a rectangle on the map
function handle_click_zoom_select(){
    var last_click_behavior;
    return function(){
        var hand_button = d3.select('.hand_button'),
            zoom_sel_button = d3.select('.brush_zoom_button');
        if(zoom_sel_button.classed("active")){
            zoom_sel_button.style('box-shadow', "none").classed("active", false);
            if(last_click_behavior == "zoom"){
                map.on("mousedown", null);
                zoom.on("zoom", zoom_without_redraw);
                map.on("mousemove.zoomRect", null).on("mouseup.zoomRect", null);
                hand_button.style('box-shadow', 'inset 2px 2px 1px black').classed("active", true);
            } else {
                zoom.on("zoom", null);
                map.on("mousedown", null)
                    .on("mousemove.zoomRect", null)
                    .on("mouseup.zoomRect", null);
            }
        } else {
            if(hand_button.classed("active")){
                hand_button.style('box-shadow', "none")
                            .classed("active", false);
                zoom.on("zoom", null);
                last_click_behavior = "zoom";
            } else last_click_behavior = "";
            zoom_sel_button.classed("active", true);
            zoom_sel_button.style('box-shadow', 'inset 2px 2px 1px black');
            map.on("mousedown", function(){
                var e = this,
                    origin = d3.mouse(e),
                    rect = d3.select("svg").append("g").append("rect").attr("class", "zoom_rect");
                d3.select("body").classed("noselect", true);
                origin[0] = Math.max(0, Math.min(w, origin[0]));
                origin[1] = Math.max(0, Math.min(h, origin[1]));
                map.on("mousemove.zoomRect", function() {
                        var m = d3.mouse(e);
                        m[0] = Math.max(0, Math.min(w, m[0]));
                        m[1] = Math.max(0, Math.min(h, m[1]));
                        rect.attr("x", Math.min(origin[0], m[0]))
                        .attr("y", Math.min(origin[1], m[1]))
                        .attr("width", Math.abs(m[0] - origin[0]))
                        .attr("height", Math.abs(m[1] - origin[1]));
                        })
                   .on("mouseup.zoomRect", function() {
                        map.on("mousemove.zoomRect", null).on("mouseup.zoomRect", null);
                        d3.select("body").classed("noselect", false);
                        var m = d3.mouse(e);
                        m[0] = Math.max(0, Math.min(w, m[0]));
                        m[1] = Math.max(0, Math.min(h, m[1]));
                        if (m[0] !== origin[0] && m[1] !== origin[1]) {
                            var b = [origin, m]
                            var s = Math.abs(.95 / Math.max((b[1][0] - b[0][0]) / w, (b[1][1] - b[0][1]) / h)),
                                t = [-Math.abs((w - s * (b[1][0] + b[0][0])) / 2) + proj.translate()[0],
                                     -Math.abs((h - s * (b[1][1] + b[0][1])) / 2) + proj.translate()[1]];
                            console.log(s, t);
                            zoom.scale(s);
                            zoom.translate(t);
                        }
                        rect.remove();
                        zoom_without_redraw();
                      }, true);
                d3.event.stopPropagation();
            });

        }
    }
}

function get_map_template(){
    var map_config = new Object(),
        layers_style = [],
        layers = map.selectAll("g.layer"),
        map_title = document.getElementById('map_title'),
        user_id = document.getElementById('user_id').innerHTML,
        displayed_legend = d3.selectAll(".legend_feature:not(.title)");

    map_config.projection = current_proj_name;
    map_config.projection_scale = proj.scale();
    map_config.projection_translate = proj.translate();
    map_config.projection_center = proj.center();
    map_config.projection_rotation = proj.rotate();
    map_config.zoom_translate = zoom.translate();
    map_config.zoom_scale = zoom.scale();
    map_config.div_width = +w;
    map_config.div_height = +h;
    map_config.n_layers = layers[0].length;
    map_config.displayed_legend = displayed_legend.size() > 0 ? true : false;

    if(map_title){
        map_config.title = {
            "content": map_title.textContent,
            "x": map_title.getAttribute("x"),
            "y": map_title.getAttribute("y"),
            "style": map_title.getAttribute("style")
            };
    }

    for(let i=map_config.n_layers-1; i > -1; --i){
        let layer_name = layers[0][i].id,
            nb_ft = current_layers[layer_name].n_features,
            selection;

        layers_style[i] = new Object();
        layers_style[i].layer_name = layer_name;
        layers_style[i].n_features = nb_ft;

        if(current_layers[layer_name]["stroke-width-const"])
            layers_style[i]["stroke-width-const"] = current_layers[layer_name]["stroke-width-const"];

        if(current_layers[layer_name].fixed_stroke)
            layers_style[i].fixed_stroke = current_layers[layer_name].fixed_stroke;

        if(current_layers[layer_name].colors_breaks)
            layers_style[i].colors_breaks = JSON.stringify(current_layers[layer_name].colors_breaks);

        if(layer_name.indexOf('PropSymbols') !== -1){
            let type_symbol = current_layers[layer_name].symbol;
            selection = map.select("#" + layer_name).selectAll(type_symbol);
            layers_style[i].symbol = type_symbol;
            layers_style[i].rendered_field = current_layers[layer_name].rendered_field;
            layers_style[i].renderer = current_layers[layer_name].renderer;
            layers_style[i].size = current_layers[layer_name].size;
            layers_style[i].fill_color = current_layers[layer_name].fill_color;
            layers_style[i].ref_layer_name = current_layers[layer_name].ref_layer_name;
            layers_style[i].features_order = JSON.stringify(current_layers[layer_name].features_order);
        } else if (current_layers[layer_name].targeted){
            selection = map.select("#" + layer_name).selectAll("path");
            layers_style[i].fill_opacity = selection.style("fill-opacity");
            layers_style[i].targeted = true;
            layers_style[i].topo_geom = [user_id, layer_name, "NQ"].join('_');
            layers_style[i].fill_color = current_layers[layer_name].fill_color;
            if(current_layers[layer_name].renderer && current_layers[layer_name].renderer.startsWith("Choro")){
                layers_style[i].renderer = current_layers[layer_name].renderer;
                layers_style[i].rendered_field = current_layers[layer_name].rendered_field;
            }
        } else if (current_layers[layer_name].renderer == "Stewart"
                    || current_layers[layer_name].renderer == "Gridded"
                    || current_layers[layer_name].renderer == "Carto_doug"){
            selection = map.select("#" + layer_name).selectAll("path");
            layers_style[i].renderer = current_layers[layer_name].renderer;
            layers_style[i].topo_geom = [user_id, layer_name, "NQ"].join('_');
            layers_style[i].fill_color = current_layers[layer_name].fill_color;
            layers_style[i].rendered_field = current_layers[layer_name].rendered_field;
            layers_style[i].ref_layer_name = current_layers[layer_name].ref_layer_name;
        } else if (current_layers[layer_name].renderer == "Links"
                    || current_layers[layer_name].renderer == "DiscLayer"){
            selection = map.select("#" + layer_name).selectAll("path");
            layers_style[i].fill_color = current_layers[layer_name].fill_color;
            layers_style[i].topo_geom = [user_id, layer_name, "NQ"].join('_');
            layers_style[i].rendered_field = current_layers[layer_name].rendered_field;
            layers_style[i].ref_layer_name = current_layers[layer_name].ref_layer_name;
            layers_style[i].size = current_layers[layer_name].size;
            layers_style[i].min_display = current_layers[layer_name].min_display;
            if(current_layers[layer_name].renderer == "DiscLayer"){
                layers_style[i].result = new Array(nb_ft)
                for(let j = 0; j < nb_ft; j++)
                    layers_style[i].result[j] = nb_ft;
            } else {
                layers_style[i].topo_geom = [user_id, layer_name, "NQ"].join('_');
                layers_style[i].linksById = current_layers[layer_name].linksById.splice(0, nb_ft)
            }
        } else {
            selection = map.select("#" + layer_name).selectAll("path");
        }
        layers_style[i].stroke_opacity = selection.style("stroke-opacity");
        layers_style[i].fill_opacity = selection.style("fill-opacity");
    }

    return Q.all(layers_style.map( obj => {return obj.topo_geom ? request_data("GET", "/get_layer/" + obj.topo_geom, null) : null}))
        .then(function(result){
            for(let i = 0; i < layers_style.length; i++){
                    if(result[i] && result[i].target){
                        layers_style[i].topo_geom = result[i].target.responseText;
                    }
                }
            return JSON.stringify({"map_config": map_config, "layers": layers_style});;
        });
}

// Function triggered when the user request a download of its map preferences
function save_map_template(){
    get_map_template().then(
        function(json_params){
            let dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(json_params),
                dlAnchorElem = document.getElementById('downloadAnchorElem');
            dlAnchorElem.setAttribute("href", dataStr);
            dlAnchorElem.setAttribute("download", "noname_properties.json");
            dlAnchorElem.click();
    });
}

//////////////////////////////////////////////////////////////////////////////
// Zooming functions (some from http://bl.ocks.org/linssen/7352810)
//////////////////////////////////////////////////////////////////////////////

function zoom_without_redraw(){
    let z_scale = zoom.scale(),
        rot_val = canvas_rotation_value || "";

    map.selectAll("g.layer")
              .transition()
              .duration(50)
              .style("stroke-width", function(){
                    let lyr_name = this.id;
                    if(!(current_layers[lyr_name].fixed_stroke))
                        return current_layers[lyr_name]['stroke-width-const'] / z_scale +  "px";
                    else
                        return this.style.strokeWidth;
                })
              .attr("transform", [rot_val,"translate(", zoom.translate(), "),",
                                 "scale(", z_scale, ")"].join(''));

    if(scaleBar.displayed)
        scaleBar.update();
};

function interpolateZoom(translate, scale) {
    var self = this;
    return d3.transition().duration(225).tween("zoom", function () {
        var iTranslate = d3.interpolate(zoom.translate(), translate),
            iScale = d3.interpolate(zoom.scale(), scale);
        return function (t) {
            zoom.scale(iScale(t)).translate(iTranslate(t));
            zoom_without_redraw()
        };
    });
}

function zoomClick() {
    var clicked = d3.event.target,
        direction = 1,
        factor = 0.1,
        target_zoom = 1,
        center = [w / 2, h / 2],
        translate = zoom.translate(),
        translate0 = [],
        l = [],
        view = {x: translate[0], y: translate[1], k: zoom.scale()};

    d3.event.preventDefault();
    direction = (this.id === 'zoom_in') ? 1 : -1;
    target_zoom = zoom.scale() * (1 + factor * direction);

    translate0 = [(center[0] - view.x) / view.k, (center[1] - view.y) / view.k];
    view.k = target_zoom;
    l = [translate0[0] * view.k + view.x, translate0[1] * view.k + view.y];

    view.x += center[0] - l[0];
    view.y += center[1] - l[1];

    interpolateZoom([view.x, view.y], view.k);
}


//////////////////////////////////////////////////////////////////////////////
// Rotation functions :
//////////////////////////////////////////////////////////////////////////////

function rotate_global(angle){
    canvas_rotation_value = ["rotate(", angle, ",", w / 2,",", h / 2, ")"].join('');
    map.selectAll("g.layer")
      .transition()
      .duration(10)
      .attr("transform", [canvas_rotation_value,
                          ",translate(", zoom.translate(), "),",
                          "scale(", zoom.scale(), ")"].join(''));
    if(northArrow.displayed){
        let current_transform = northArrow.svg_node.attr("transform");
        if(current_transform)
            northArrow.svg_node.attr("transform", ["rotate(", angle, ",",northArrow.x,",", northArrow.y, "),"].join('') + current_transform);
        else
            northArrow.svg_node.attr("transform",  ["rotate(", angle, ",",northArrow.x,",", northArrow.y, ")"].join(''));
        }
};

function change_projection(proj_name) {
    var current_proj_name = proj_name.split('()')[0].split('.')[2];

    // Update global variables:
    proj = eval(proj_name);
    path = d3.geo.path().projection(proj);
    t = proj.translate();
    s = proj.scale();

    // Do the reprojection :
    reproj();

    // Set specifics mouse events according to the projection :
    if(strContains(current_proj_name, 'orthographic')){
        var current_params = proj.rotate();
        rotation_param.append("div").attr("class", "options_ortho").html("Projection center (φ-axis rotation)")
                .insert("input")
                .attr({type: "range", id: "form_projection_phi"})
                .attr({value: current_params[1], min: -180, max: 180, step: 0.5})
                .on("input", function(){handle_proj_center_button([null, this.value, null])})

        rotation_param.append("div").attr("class", "options_ortho").html("Projection center (γ-axis rotation)")
                .insert("input")
                .attr({type: "range", id: "form_projection_gamma"})
                .attr({value: current_params[2], min: -90, max: 90, step: 0.5})
                .on("input", function(){handle_proj_center_button([null, null, this.value])});
    } else {
        var options_ortho = d3.selectAll(".options_ortho");
        if(options_ortho.node())
            options_ortho.remove();
    }
    d3.select("svg").on("mousedown", null)
                    .on("mousemove", null)
                    .on("mouseup", null);
}

//////////////////////////////////////////////////////////////////////////////
// Used for the sphere rotation when orthographic projection is enabled :
//////////////////////////////////////////////////////////////////////////////

var λ = d3.scale.linear()
    .domain([0, w])
    .range([-180, 180]);

var φ = d3.scale.linear()
    .domain([0, h])
    .range([90, -90]);

// Function to switch the visibility of a layer the open/closed eye button
function handle_active_layer(name){
    var fill_value, parent_div, selec;
    if(!name) {
        selec = this;
        parent_div = selec.parentElement;
        name = parent_div.parentElement.getAttribute("layer_name");
    } else {
        selec = document.querySelector("#sortable ." + name + " .active_button");
        parent_div = selec.parentElement;
    }
    let func = function() { handle_active_layer(name); };
    if(selec.id == "eye_closed"){
        fill_value = 1;
        let eye_open = make_eye_button("open");
        eye_open.onclick = func;
        parent_div.replaceChild(eye_open, selec);
    } else {
        fill_value = 0;
        let eye_closed = make_eye_button("closed");
        eye_closed.onclick = func;
        parent_div.replaceChild(eye_closed, selec);
    }
    map.select("#"+name).style("opacity", fill_value);
    map.selectAll(".lgdf_" + name).style("visibility", fill_value == 0 ? "hidden" : "initial");
}

// Function to handle the title add and changes
function handle_title(txt){
    var title = d3.select("#map_title");
    if(title.node()){
        title.text(txt);
    } else {
        map.append("g")
             .attr("class", "legend_feature title")
          .insert("text")
             .attr({id: "map_title", x: "50%", y: "8%", "alignment-baseline": "middle", "text-anchor": "middle"})
             .style({"font-family": "Arial, Helvetica, sans-serif", "font-size": "20px", position: "absolute", color: "black"}).text(txt);
    }
}

function handle_title_properties(){
    var title = d3.select("#map_title");
    if(!title.node()){
        alert("No title no style...");
        return;
    }
    var title_props = {
        size: title.style("font-size"),
        color: title.style("fill"),
        position_x: title.attr("x"),
        position_y: title.attr("y"),
        font_family: title.style("font-family")
        };

    // Properties on the title are changed in real-time by the user then it will be rollback to original properties if Cancel is clicked
    make_confirm_dialog("", "Valid", "Cancel", "Title properties", "mapTitleitleDialogBox", 280).then(
        function(confirmed){ if(!confirmed)
            title.style("font-size", title_props.size)
                .style("fill", title_props.color)
                .style("font-family", title_props.font_family)
                .attr({x: title_props.position_x, y: title_props.position_y});
        });
    var box_content = d3.select(".mapTitleitleDialogBox").append("div");
    var available_fonts = [
        ['Arial', 'Arial,Helvetica,sans-serif'],
        ['Arial Black', 'Arial Black,Gadget,sans-serif'],
        ['Comic Sans MS', 'Comic Sans MS,cursive,sans-serif'],
        ['Impact', 'Impact,Charcoal,sans-serif'],
        ['Georgia', 'Georgia,serif'],
        ['Lucida', 'Lucida Sans Unicode,Lucida Grande,sans-serif'],
        ['Palatino', 'Palatino Linotype,Book Antiqua,Palatino,serif'],
        ['Tahoma', 'Tahoma,Geneva,sans-serif'],
        ['Trebuchet MS', 'Trebuchet MS, elvetica,sans-serif'],
        ['Verdana', 'Verdana,Geneva,sans-serif']
        ];
    box_content.append("p").html("Font-size :<br>")
        .insert("input").attr({type: "number", min: 2, max:40, step:1, value: +title_props.size.split("px")[0]}).style({width: "50px"})
        .on("change", function(){  title.style("font-size", this.value + "px");  });
    box_content.append("p").html("x position (% from the left side) :<br>")
        .insert("input").attr({type: "number", min: 0, max:100, step:1, value: +title_props.position_x.split("%")[0]}).style({width: "50px"})
        .on("change", function(){  title.attr("x", this.value + "%");  });
    box_content.append("p").html("y position (% from the top) :<br>")
        .insert("input").attr({type: "number", min: 0, max:100, step:1, value: +title_props.position_y.split("%")[0]}).style({width: "50px"})
        .on("change", function(){  title.attr("y", this.value + "%");  });
    box_content.append("p").html("Font color :<br>")
        .insert("input").attr({type: "color", value: title_props.color})
        .on("change", function(){  title.style("fill", this.value);  });
    var font_select = box_content.append("p").html("Font family :<br>")
        .insert("select").attr("class", "params")
        .on("change", function(){  title.style("font-family", this.value); });
    available_fonts.forEach(function(font){ font_select.append("option").text(font[0]).attr("value", font[1]) });
    font_select.node().selectedIndex = available_fonts.map(d => d[1] == title_props.font_family ? "1" : "0").indexOf("1");
    return;
}

// Function to change (one of ) the three rotations axis of a d3 projection
// and redraw all the path in respect to that
function handle_proj_center_button(param){
    let current_rotation = proj.rotate();
    if(param[0]){
        proj.rotate([param[0] - w/2, current_rotation[1], current_rotation[2]]);
        map.selectAll("path").attr("d", path);
    }
    if(param[1]){
        proj.rotate([current_rotation[0], param[1] - h/2, current_rotation[2]]);
        map.selectAll("path").attr("d", path);
    }
    if(param[2]){
        proj.rotate([current_rotation[0], current_rotation[1], param[2] - h/2]);
        map.selectAll("path").attr("d", path);
    }
    reproj_symbol_layer();
}

/** Function triggered by the change of map/canvas size
* @param {Array} shape - An Array of two elements : [width, height] to use;
*                generally only used once at the time so `shape` values
*                are like [null, 750] or [800, null]
*                but also works with the 2 params together like [800, 750])
*/
function canvas_mod_size(shape){
    if(shape[0]){
        w = +shape[0];
        map.attr("width", w)
            .call(zoom_without_redraw);
        map_div.style("width", w + "px");
        if(w + 360 + 30 < window.innerWidth){
            document.querySelector(".light-menu").style.right = '-30px';
        }
    }
    if(shape[1]){
        h = +shape[1];
        map.attr("height", h)
            .call(zoom_without_redraw);
        map_div.style("height", h + "px");

        // And change the position of the `source` element displayed in the bottom of the map :
        //d3.selectAll(".source_block").select("text").attr("y", h - 10);
    }
}

function export_compo_svg(){
    let targetSvg = document.getElementById("svg_map"),
        serializer = new XMLSerializer(),
        source = serializer.serializeToString(targetSvg);

    if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
        source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
    }
    if(!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)){
        source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
    }

    source = ['<?xml version="1.0" standalone="no"?>\r\n', source].join('');

    let url = "data:image/svg+xml;charset=utf-8,"+encodeURIComponent(source),
        dl_link = document.createElement("a");

    dl_link.download = "export.svg";
    dl_link.href = url;
    dl_link.dataset.downloadurl = ["image/svg", dl_link.download, dl_link.href].join(':');
    document.body.appendChild(dl_link);
    dl_link.click();
    dl_link.remove();

}

function export_compo_png(){
    // Todo : ask for output format (svg / png) before conversion / ! \
    var targetCanvas = d3.select("body").append("canvas").attr({id: "canvas_map_export", height: h, width: w}).node(),
        targetSVG = document.querySelector("#svg_map"),
        svg_xml = (new XMLSerializer()).serializeToString(targetSVG),
        ctx = targetCanvas.getContext('2d'),
        mime_type = "image/png",
        img = new Image();

    img.src = "data:image/svg+xml;base64," + btoa(svg_xml);
    img.onload = function() {
        ctx.drawImage(img, 0, 0);
        var imgUrl = targetCanvas.toDataURL(mime_type),
            dl_link = document.createElement("a");

        dl_link.download = "export.png";
        dl_link.href = imgUrl;
        dl_link.dataset.downloadurl = [mime_type, dl_link.download, dl_link.href].join(':');
        document.body.appendChild(dl_link);
        dl_link.click();
        dl_link.remove();
        targetCanvas.remove();
    }
}

function apply_user_preferences(json_pref){
    let preferences = JSON.parse(json_pref),
        map_config = preferences.map_config,
        layers = preferences.layers;

    // Update some global variables with the readed values in order to retrieve
    // the same map size / orientation / zoom / etc ...
    w = +map_config.div_width;
    h = +map_config.div_height;
    canvas_mod_size([w, h]);
    document.getElementById("input-width").value = w;
    document.getElementById("input-height").value = h;
    current_proj_name = map_config.projection;
    proj = eval(available_projections.get(current_proj_name));
    s = map_config.projection_scale;
    t = map_config.projection_translate;
    proj.scale(s).translate(t).rotate(map_config.projection_rotation);
    path = d3.geo.path().projection(proj);
    map.selectAll("path").attr("d", path);

    for(let i = map_config.n_layers - 1; i > -1; --i){
        let layer_name = layers[i].layer_name,
            symbol,
            layer_selec;
        let fill_opacity = layers[i].fill_opacity,
            stroke_opacity = layers[i].stroke_opacity;

        if(layers[i].topo_geom && layer_name != "Sphere" && layer_name != "Simplified_land_polygons"){
            let tmp = {skip_alert: true};
            if(layers[i].targeted) target_layer_on_add = true;
            else if(layers[i].renderer)tmp['result_layer_on_add'] = true;
            add_layer_topojson(layers[i].topo_geom, tmp);

            symbol = "path";
            layer_selec = map.select("#" + layer_name);

            current_layers[layer_name].renderer = layers[i].renderer;
            current_layers[layer_name].rendered_field = layers[i].rendered_field;
            current_layers[layer_name]['stroke-width-const'] = layers[i]['stroke-width-const'];
            current_layers[layer_name].fixed_stroke = layers[i].fixed_stroke;
            if(layers[i].ref_layer_name)
                current_layers[layer_name].ref_layer_name = layers[i].ref_layer_name;
            if(layers[i].size)
                current_layers[layer_name].size = layers[i].size;
            if(layers[i].colors_breaks)
                current_layers[layer_name].colors_breaks = JSON.parse(layers[i].colors_breaks);
            if(layers[i].fill_color)
                current_layers[layer_name].fill_color = layers[i].fill_color;

            if(layers[i].renderer == "Choropleth"
                || layers[i].renderer == "Stewart"
                || layers[i].renderer == "Gridded"){
                layer_selec.selectAll("path")
                        .style("fill", (d,j) => layers[i].fill_color.class[j])
                if(layers[i].renderer == "Choropleth"){
                    insert_legend_button(layer_name);
                    binds_layers_buttons(layer_name);
                }
            } else if (layers[i].renderer == "Links"){
                current_layers[layer_name].LinksById = layers[i].LinksById;
                current_layers[layer_name].min_display = layers[i].min_display;
            } else if (layers[i].renderer == "DiscLayer"){
                current_layers[layer_name].result = new Map(layers[i].result);
                layer_selec.selectAll("path").style("stroke-width", (d,i) => { return current_layers[layer_name].result.get(d.id); });
            }
        layer_selec.selectAll(symbol)
                .style("fill-opacity", fill_opacity)
                .style("stroke-opacity", stroke_opacity)
        if(layers[i].fill_color.random)
            layer_selec
                .selectAll(symbol)
                .style("fill", () => Colors.names[Colors.random()]);
        } else if (layer_name == "Sphere" || layer_name == "Simplified_land_polygons"){
            layer_selec = map.select("#"+layer_name);
            symbol = "path";
            layer_selec.selectAll(symbol)
                    .style("fill-opacity", fill_opacity)
                    .style("stroke-opacity", stroke_opacity)
        } else if (layers[i].renderer && layers[i].renderer.startsWith("PropSymbol")){
            let layer_to_append = map.append("g").attr("id", layer_name).attr("class", "result_layer layer");
            let zs = zoom.scale();
            let full_params = JSON.parse(layers[i].features_order);
            let n_ft = full_params.length;
            symbol = layers[i].symbol;

            current_layers[layer_name] = {
                renderer: layers[i].renderer,
                rendered_field:layers[i].rendered_field,
                'stroke-width-const': layers[i]['stroke-width-const'],
                fixed_stroke: layers[i].fixed_stroke,
                size: layers[i].size,
                ref_layer_name: layers[i].ref_layer_name,
                fill_color: layers[i].fill_color,
                features_order: full_params,
                symbol: symbol,
                n_features: n_ft,
                }

            let ref_size = current_layers[layer_name].size[0],
                max_size = current_layers[layer_name].size[1];

            if(layers[i].colors_breaks)
                current_layers[layer_name].colors_breaks = JSON.parse(layers[i].colors_breaks);

            if(symbol == "circle"){
                for(let ii = 0; ii < n_ft; ii++){
                    let params = full_params[ii];
                    layer_to_append.append('circle')
                        .attr('cx', params[2][0])
                        .attr("cy", params[2][1])
                        .attr("r", ref_size / zs + params[1])
                        .attr("id", ["PropSymbol_", ii , " feature_", params[0]].join(''))
                        .style("fill", params[3])
                        .style("stroke", "black")
                        .style("stroke-width", 1 / zs);
                }
            } else if(symbol == "rect"){
                for(let ii = 0; ii < n_ft; ii++){
                    let params = full_params[ii],
                        size = ref_size / zs + params[1];

                    layer_to_append.append('rect')
                        .attr('x', params[2][0] - size/2)
                        .attr("y", params[2][1] - size/2)
                        .attr("height", size)
                        .attr("width", size)
                        .attr("id", ["PropSymbol_", ii , " feature_", params[0]].join(''))
                        .style("fill", params[3])
                        .style("stroke", "black")
                        .style("stroke-width", 1 / zs);
                };
            }
            layer_selec = map.select("#"+layer_name);
            layer_selec.selectAll(symbol)
                    .style("fill-opacity", fill_opacity)
                    .style("stroke-opacity", stroke_opacity);

            let layers_listed = layer_list.node(),
                li = document.createElement("li");

            li.setAttribute("layer_name", layer_name);
            li.setAttribute("class", "ui-state-default sortable_result " + layer_name);
            li.setAttribute("layer-tooltip", ["<b>", layer_name, "</b> - Point - ", n_ft, " features"].join(''));
            li.innerHTML = ['<div class="layer_buttons">', sys_run_button_t2, button_trash, button_zoom_fit, button_legend, eye_open0, button_type_blank['Point'], "</div> ", layer_name].join('');
            layers_listed.insertBefore(li, layers_listed.childNodes[0]);
            binds_layers_buttons();

        } else {
            null;
        }

        if(layers[i].is_result && map_config.displayed_legend)
            handle_legend(layer_name);
    }
    zoom.translate(map_config.zoom_translate).scale(map_config.zoom_scale);
    zoom_without_redraw();

    if(map_config.title){
        let title = document.getElementById("map_title");
        if(title){
            title.textContent = map_config.title.content;
            title.setAttribute("x", map_config.title.x);
            title.setAttribute("y", map_config.title.y);
            title.setAttribute("style", map_config.title.style);
        } else {
            title = map.append("g")
                     .attr("class", "legend_feature title")
                  .insert("text")
                     .attr({id: "map_title", x: map_config.title.x, y: map_config.title.y, "alignment-baseline": "middle", "text-anchor": "middle"})
                     .text(map_config.title.content);
            title.node().setAttribute("style", map_config.title.style);
        }
    }
}

function handle_export(){
    d3.select("body").append("div")
        .attr("id", "dialog").attr("class", "exportDialogBox")
        .attr("title", "Choose a format...").html("");

    let dialogBox = $("#dialog"),
        box_content = d3.select("#dialog").append("div");

    box_content.append("button")
        .attr("class", "button_st2")
        .html(i18next.t("Export to PNG"))
        .on("click", function(){
            dialogBox.dialog("destroy").remove();
            export_compo_png();
        });

    box_content.append("button")
        .attr("class", "button_st2")
        .html(i18next.t("Export to SVG"))
        .on("click", function(){
            dialogBox.dialog("destroy").remove();
            export_compo_svg();
        });

    box_content.append("button")
        .attr("class", "button_st2")
        .html(i18next.t("Export layers to a geographic format"))
        .on("click", function(){
            dialogBox.dialog("destroy").remove();
            make_export_layer_box();
        });

    dialogBox.dialog({
        position: { my: "center", at: "top" },
        modal: false,
        close: function(event, ui){ $(this).dialog("destroy").remove(); }
      });
}

function make_export_layer_box(){
    d3.select("body").append("div")
        .attr({id: "dialogGeoExport", class: "exportGeoDialogBox", title: "Choose layer and datatype..."})
        .style("font-size", "0.6em")
        .html("");

    let dialogBox = $("#dialogGeoExport"),
        box_content = d3.select("#dialogGeoExport").append("div");

    dialogBox.dialog({
        position: { my: "center", at: "top" },
        width: 400,
        modal: false,
        close: function(event, ui){ $(this).dialog("destroy").remove(); }
      });

    let layer_names = Object.getOwnPropertyNames(current_layers).filter(name => {
        if(sample_no_values.has(name))
            return 0;
        else if(current_layers[name].renderer
                && (current_layers[name].renderer.indexOf("PropSymbols") > -1
                    || current_layers[name].renderer.indexOf("Dorling") > -1))
            return 0;
        return 1;
    });

    box_content.append("h3").html(i18next.t("Layer export"));

    let selec_layer = box_content.append("p").html("Layer to export ")
             .insert("select").attr("id", "layer_to_export");

    let selec_type = box_content.append("p").html("Datatype ")
             .insert("select").attr("id", "datatype_to_use");

    let selec_projection = box_content.append("p").html("Projection ")
             .insert("select").attr("id", "projection_to_use");

    let proj4_input = box_content.append("input")
                                .attr("id", "proj4str")
                                .style("display", "none")
                                .style("width", "200px");

    layer_names.forEach( name => {
        selec_layer.append("option").attr("value", name).text(name);
    });

    ["GeoJSON", "TopoJSON", "ESRI Shapefile", "GML", "KML"].forEach( name => {
        selec_type.append("option").attr("value", name).text(name);
    });

    [["Geographic coordinates / WGS84 (EPSG:4326)", "epsg:4326"],
     ["Web-mercator / WGS84 (EPSG:3857)", "epsg:3857"],
     ["LAEA Europe / ETRS89 (EPSG:3035)", "epsg:3035"],
     ["USA Albers Equal Area / NAD83", "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs"],
     ["British National Grid / OSGB36 (EPSG:27700)", "epsg:27700"],
     ["Lambert-93 / RGF93-GRS80 (EPSG:2154)", "epsg:2154"],
     ["Eckert IV / WGS84", "+proj=eck4 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs "],
     ["Enter any valid Proj.4 string...", "proj4string"]].forEach(projection => {
        selec_projection.append("option").attr("value", projection[1]).text(projection[0]);
    });

    selec_type.on("change", function(){
        if(this.value == "TopoJSON" || this.value == "KML"){
            selec_projection.node().options.selectedIndex = 0;
            selec_projection.attr("disabled", true);
        } else {
            selec_projection.attr("disabled", null);
        }
    });

    selec_projection.on("change", function(){
        if(this.value == "proj4string")
            proj4_input.style("display", "initial");
        else
            proj4_input.style("display", "none");
    });

    let extensions = new Map([
        ["GeoJSON", "geojson"],
        ["TopoJSON", "topojson"],
        ["ESRI Shapefile", "zip"],
        ["GML", "zip"],
        ["KML", "kml"]]);

    box_content.append("p").append("button")
            .attr("class", "button_st2")
            .html("Export")
            .on("click", function(){
                let layer = selec_layer.node().value,
                    type = selec_type.node().value,
                    projec = selec_projection.node().value;
                let formToSend = new FormData();
                formToSend.append("layer", layer);
                formToSend.append("layer_name", current_layers[layer].key_name);
                formToSend.append("format", type);
                if(projec == "proj4string")
                    formToSend.append("projection", JSON.stringify({"proj4string" : proj4_input.node().value}));
                else
                    formToSend.append("projection", JSON.stringify({"name" : projec}));
                $.ajax({
                    processData: false,
                    contentType: false,
                    url: '/get_layer2',
                    data: formToSend,
                    type: 'POST',
                    error: function(error) { console.log(error); },
                    success: function(data, code, obj){
                        if(data.indexOf("Error:") == 0){
                            swal("Oops...", "Something went wrong : " + data.substring(6, data.length), "error");
                            return;
                        }
                        let ext = extensions.get(type),
                            dataStr;

                        if(ext.indexOf("json") > -1)
                            dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(data);
                        else if (ext.indexOf("kml") > -1)
                            dataStr = "data:text/xml;charset=utf-8," + encodeURIComponent(data);
                        else
                            dataStr = "data:application/zip;base64," + data;

                        let dlAnchorElem = document.getElementById('downloadAnchorElem');
                        dlAnchorElem.setAttribute("href", dataStr);
                        dlAnchorElem.setAttribute("download", [layer, ext].join('.'));
                        dlAnchorElem.click();
                    }
                });
                dialogBox.dialog("destroy").remove();
            });
}

// Only ask for confirmation before leaving page if things have been done
// (layer added, etc..)
window.addEventListener("beforeunload", event => {
    event.returnValue = (targeted_layer_added || Object.getOwnPropertyNames(result_data).length > 0) ? "Confirm exit" : "";
});


// Remove some layers from the server when user leave the page
// (ie. result layers are removed but targeted layer and layout layers stay
// in cache as they have more chance to be added again)
window.addEventListener("unload", function(){
    let layer_names = Object.getOwnPropertyNames(current_layers).filter(name => {
        if(sample_no_values.has(name) || !(current_layers[name].hasOwnProperty("key_name")))
            return 0;
        else if(current_layers[name].targeted)
            return 0;
        else if(current_layers[name].renderer
                && (current_layers[name].renderer.indexOf("PropSymbols") > -1
                    || current_layers[name].renderer.indexOf("Dorling") > -1))
            return 0;
        return 1;
    });
    if(layer_names.length){
        let formToSend = new FormData();
        layer_names.forEach(function(name){
            formToSend.append("layer_name", current_layers[name].key_name);
        });
        navigator.sendBeacon("/layers/delete", formToSend);
    }
}, false);

</script>
</body>
</html>
