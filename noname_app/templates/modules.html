<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta  content="text/html" charset="utf-8"  http-equiv="content-type">
    <meta  http-equiv="X-UA-Compatible"  content="IE=edge">
    <meta  name="viewport"  content="width=device-width, initial-scale=1, user-scalable=yes">
    <title> {{ app_name }} </title>
    <link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
    <link href="/static/css/discretization.css" rel="stylesheet" type="text/css">
    <link href="/static/css/jquery.qtip.min.css" rel="stylesheet" type="text/css">
    <link href="/static/css/style.css" rel="stylesheet"  type="text/css">
    <link href="/static/css/datatables.min.css" rel="stylesheet" type="text/css">
    <link href="/static/css/context-menu.css" rel="stylesheet" type="text/css">
    <link href="/static/css/sweetalert2.min.css" rel="stylesheet" type="text/css">
    <script  src="/static/js/lib/d3.v4.min.js"></script>
    <script  src="/static/js/lib/d3-geo-projection.v1.min.js"></script>
    <script  src="/static/js/lib/d3-selection-multi.v1.min.js"></script>
    <script  src="/static/js/lib/topojson.v1.min.js"></script>
    <script  src="/static/js/lib/jquery-2.2.1.min.js"></script>
    <script  src="/static/js/lib/jquery-ui.min.js"></script>
    <script  src="/static/js/lib/geostats.min.js"></script>
    <script  src="/static/js/lib/colorbrewer.v1.min.js"></script>
    <script  src="/static/js/lib/jschardet.min.js"></script>
    <script  src="/static/js/lib/q.js"></script>
    <script  src="/static/js/lib/i18next.min.js"></script>
    <script src="/static/js/lib/loc-i18next.min.js"></script>
    <script  src="/static/js/lib/i18nextXHRBackend.min.js"></script>
    <script  src="/static/js/lib/jquery.qtip.min.js"></script>
    <script  src="/static/js/lib/sweetalert2.min.js"></script>
    <script  src="/static/js/lib/datatables.min.js"></script>
    <script  src="/static/js/txt_annotation.js"></script>
    <script  src="/static/js/lib/context-menu.js"></script>
    <script  src="/static/js/interface.js"></script>
    <script  src="/static/js/discrtiz_links_discont.js"></script>
    <script  src="/static/js/layers_style_popup.js"></script>
    <script  src="/static/js/discretization_panel.js"></script>
    <script  src="/static/js/function.js"></script>
    <script  src="/static/js/legend.js"></script>
    <script  src="/static/js/join_popup.js"></script>
    <script  src="/static/js/colors_helpers.js"></script>
  </head>
  <body>
      <div id="header">
        <p style="display:inline;margin-left:10px;"><i><a href="/"> {{ app_name }}</a></i></p>
        <p id="rgt" class="header_options"><a href="https://github.com/riatelab/noname-stuff/">Sources</a>  <a href="">Documentation</a>&emsp;</p></div>
      <div id="menu"></div>
      <div id="menu_block"></div>
  	 <div id="map"></div>
      <a id="downloadAnchorElem" style="display:none"></a>
<script>
"use strict";

function cleanInterface(){
    let menu_elements = document.getElementById("menu");
    for(let i = menu_elements.children.length - 1; i > -1; i--){
        menu_elements.children[i].remove();
    }
}

/**
* Function setting-up main elements of the interface
*
* Some of the variables created here are put in global/window scope
* as they are gonna be frequently used
*
*/
function setUpInterface()
{
    let bg = document.createElement('div');
    bg.id = 'overlay';
    bg.style.display = "none";
    bg.innerHTML = '<p style="position: absolute; top: 11px; left: ' + w/2 + 'px; text-align: center; color: black; z-index: 2;"><img src="/static/img/ajax-loader.gif" style="width:' + w/4 + 'px"><br>' + i18next.t('app_page.common.loading_results') + ' ...</p>'
    document.body.appendChild(bg);

    let menu = d3.select("#menu"),
        accordion1 = menu.append("div").attr("id","accordion1").attr("class", "accordion"),
        accordion2_pre = menu.append("div").attr("id","accordion2_pre").attr("class", "accordion"),
        accordion2 = menu.append("div").attr("id","accordion2").attr("class", "accordion"),
        accordion3 = menu.append("div").attr("id","accordion3").attr("class", "accordion"),
        accordion4 = menu.append("div").attr("id","accordion4").attr("class", "accordion"),
        accordion5 = menu.append("div").attr("id","accordion5").attr("class", "accordion");

    accordion1.append("h3").insert("span").attr("class", "i18n").attr("data-i18n", "app_page.section1.title");
    accordion2_pre.append("h3").insert("span").attr("class", "i18n").attr("data-i18n", "app_page.section2_pre.title");
    accordion2.append("h3").insert("span").attr("class", "i18n").attr("data-i18n", "app_page.section2.title");
    accordion3.append("h3").insert("span").attr("class", "i18n").attr("data-i18n", "app_page.section3.title");
    accordion4.append("h3").insert("span").attr("class", "i18n").attr("data-i18n", "app_page.section4.title");
    accordion5.append("h3").insert("span").attr("class", "i18n").attr("data-i18n", "app_page.section5.title");

    window.section1 =  accordion1.append("div")
                        .attr("id","section1")
                        .attr("class", "i18n")
                        .attr("data-i18n", "[data-tooltip]app_page.tooltips.section1");
                        //.attr("data-tooltip", i18next.t("app_page.tooltips.section1"));
    window.section2_pre =  accordion2_pre.append("div").attr("id","section2_pre").style("padding", "0");
    window.section2 =  accordion2.append("div").attr("id","section2");
    accordion3.append("div")
        .attrs({id: "section3", class: "i18n", "data-i18n": "[data-tooltip]app_page.tooltips.section3"}),
    accordion4.append("div").attr("id","section4");
    accordion5.append("div").attr("id","section5");

    let dv1 = section1.append("div"),
        dv11 = dv1.append("div").style("width", "auto");

    dv11.append("img")
        .attrs({"id": "img_in_geom", "class": "user_panel", "src": "/static/img/b/addgeom.png", "width": "26", "height": "26",  "alt": "Geometry layer"})
        .style("cursor", "pointer")
        .on('click',  click_button_add_layer);

    dv11.append("p")
        .attrs({id: "input_geom", class: "user_panel i18n"})
        .styles({display: "inline", cursor: "pointer", "margin-left": "5px", "vertical-align": "super", "font-weight": "bold"})
        .attr("data-i18n", "[html]app_page.section1.add_geom")
        .on('click',  click_button_add_layer);

    let dv12 = dv1.append("div");
    dv12.append("img")
        .attrs({"id": "img_data_ext", "class": "user_panel", "src": "/static/img/b/addtabular.png", "width": "26", "height": "26",  "alt": "Additional dataset"})
        .style("cursor", "pointer")
        .on('click',  click_button_add_layer);

    dv12.append("p")
        .attrs({"id": "data_ext", "class": "user_panel i18n"})
        .styles({display: "inline", cursor: "pointer", "margin-left": "5px", "vertical-align": "super", "font-weight": "bold"})
        .attr("data-i18n", "[html]app_page.section1.add_ext_dataset")
        .on('click',  click_button_add_layer);

    let div_sample = dv1.append("div").attr("id", "sample_zone");
    div_sample.append("img")
        .attrs({"id": "sample_button", "class": "user_panel", "src": "/static/img/b/addsample.png", "width": "26", "height": "26",  "alt": "Sample layers"})
        .style("cursor", "pointer")
        .on('click', add_sample_layer);

    div_sample.append("span")
        .attrs({"id": "sample_link", "class": "user_panel i18n"})
        .styles({display: "inline", cursor: "pointer", "margin-left": "5px", "vertical-align": "super", "font-weight": "bold"})
        .attr("data-i18n", "[html]app_page.section1.add_sample_data")
        .on('click', add_sample_layer);

    dv1.append("p")
        .attr("id", "join_section")
        .styles({"text-align": "center", "margin-top": "2px"})
        .html("");

    dv1.append("p")
        .attr("id", "browse_section")
        .attr("align", "center")
        .html("")
        .append("button")
        .attrs({id: "browse_button", class: "button_st3 i18n", disabled: true})
        .style("font-size", "12px")
        .attr("data-i18n", "[html]app_page.section1.explore_table")
        .on("click", () => {  boxExplore.create(); });

    make_ico_choice();

    section2.append("p")
            .style("font-size", "18px")
            .attr("class", "i18n")
            .attr("data-i18n", "[html]app_page.section2.no_func");

    let section3 = d3.select("#section3");

    window.layer_list = section3.append("div")
                             .append("ul").attrs({id: "sortable", class: "layer_list"})
                             .on("mouseover", function(){
                                    $('.qtip.qtip-section3').qtip("hide")
                                })
                             .on("mouseout", function(){
                                    $('.qtip.qtip-section3').qtip("show")
                                });

    let dv3 = section3.append("div")
                    .style("padding-top", "10px").html('');

    dv3.append("img")
        .attr("src", "/static/img/b/addsample_t.png")
        .styles({cursor: "pointer", margin: "2.5px", float: "right", "border-radius": "10%"})
        .on('click', add_layout_layers);
    dv3.append("img")
        .attr("src", "/static/img/b/addgeom_t.png")
        .styles({cursor: "pointer", margin: "2.5px", float: "right", "border-radius": "10%"})
        .on("click", click_button_add_layer);

    let section4 = d3.select("#section4");
    let dv4 = section4.append("div").attr("class", "form-item").style("margin", "auto")
                    .append("ul")
                    .styles({"list-style": "outside none none",
                             display: "inline-block",
                             padding: "0px",
                             width: "100%"});

    let a = dv4.append("li").style("margin", "1px");
    a.append("p").attr("class", "list_elem_section4 i18n")
            .attr("data-i18n", "[html]app_page.section4.map_width");
    a.append("p").attr("class", "list_elem_section4")
            .insert("input").style("width", "60px").style("margin-left", "15px")
            .attrs({id: "input-width", type: "number", value: w, width: "55px"})
            .on("change", function(){canvas_mod_size([this.value,null])});

    let b = dv4.append("li").style("margin", "1px");
    b.append("p").attr("class", "list_elem_section4 i18n")
            .attr("data-i18n", "[html]app_page.section4.map_height");
    b.append("p").attr("class", "list_elem_section4")
            .insert("input").style("width", "60px").style("margin-left", "15px")
            .attrs({id: "input-height", type: "number", "value": h})
            .on("change", function(){
                canvas_mod_size([null, this.value])
            });

    let zoom_prop = svg_map.__zoom;

    let c1 = dv4.append("li").style("margin", "1px");
    c1.append("p").attr("class", "list_elem_section4 i18n")
            .attr("data-i18n", "[html]app_page.section4.map_center_x");
    c1.append("p").attr("class", "list_elem_section4")
            .insert("input").style("width", "60px").style("margin-left", "15px")
            .attrs({id: "input-center-x", type: "number", "value": round_value(zoom_prop.x, 2), step: "any"})
            .on("change", function(){
                svg_map.__zoom.x = +this.value;
                zoom_without_redraw();
            });

    let c2 = dv4.append("li").style("margin", "1px");
    c2.append("p").attr("class", "list_elem_section4 i18n")
            .attr("data-i18n", "[html]app_page.section4.map_center_y");
    c2.append("p").attr("class", "list_elem_section4")
            .insert("input").style("width", "60px").style("margin-left", "15px")
            .attrs({id: "input-center-y", type: "number", "value": round_value(zoom_prop.y, 2), step: "any"})
            .on("change", function(){
                svg_map.__zoom.y = +this.value;
                zoom_without_redraw();
            });


    let d = dv4.append("li").style("margin", "1px");
    d.append("p").attr("class", "list_elem_section4 i18n")
            .attr("data-i18n", "[html]app_page.section4.map_scale_k");
    d.append("p").attr("class", "list_elem_section4")
            .insert("input").style("width", "60px").style("margin-left", "15px")
            .attrs({id: "input-scale-k",
                    type: "number",
                    value: round_value(zoom_prop.k * proj.scale(), 2),
                    step: "any"})
            .on("change", function(){
                svg_map.__zoom.k = +this.value / proj.scale();
                zoom_without_redraw();
            });

    let e = dv4.append("li").style("margin", "1px");
    e.append("p").attr("class", "list_elem_section4 i18n")
            .attr("data-i18n", "[html]app_page.section4.map_title");
    e.append("p").attr("class", "list_elem_section4")
            .insert("input").attr("id", "title")
            .styles({"margin": "0px 0px 0px 15px"})
            .on("keyup", function(){
                handle_title(this.value);
            });
    e.insert("span")
            .styles({display: "inline", top: "4px", cursor: "pointer", "vertical-align": "sub"})
            .html(sys_run_button.replace("submit", "Title properties"))
            .on("click", handle_title_properties);

    let f = dv4.append("li").style("margin", "1px");
    f.append("p").attr("class", "list_elem_section4 i18n")
            .attr("data-i18n", "[html]app_page.section4.background_color");
    f.append("p").attr("class", "list_elem_section4")
            .insert("input")
            .styles({"vertical-align": "middle", "margin-left": "15px"})
            .attrs({type: "color", id: "bg_color", value: "#ffffff"})
            .on("change", function(){
                handle_bg_color(this.value);
            });

    let g = dv4.append("li").style("margin", "1px");
    g.append("p").attr("class", "list_elem_section4 i18n")
            .attr("data-i18n", "[html]app_page.section4.canvas_rotation");
    g.append("input")
            .attr("type", "range")
            .attr("id","form_rotate")
            .attr("value", 0).attr("min", 0)
            .attr("max", 360).attr("step", 1)
            .styles({width: "80px", "margin-left": "15px", "vertical-align": "middle"})
            .on("input", function(){
                rotate_global(this.value);
                document.getElementById("canvas_rotation_value_txt").innerHTML = this.value + "°";
            });

    g.append("span")
        .attr("id", "canvas_rotation_value_txt")
        .html("0°");

    let _h = dv4.append("li");
    _h.append("p")
            .style("cursor", "pointer")
            .html("<b>" + i18next.t("app_page.section4.layout_features") + "</b> " + sys_run_button)
            .on("click", select_layout_features);

    let section5 = d3.select("#section5");
    let dv5 = section5.append("p")
                .style("text-align", "center")
                .attr("class", "form-item");

    dv5.insert('label-item').attr("class", "i18n")
            .attr("data-i18n", "[html]app_page.section5.projection");

    let rotation_param = section5.append("div")
                            .styles({"text-align": "center", "width": "300px"});

    rotation_param.append("p")
            .attrs({id: "rotation_params", class: "i18n"})
            .attr("data-i18n", "[html]app_page.section5.projection_center_lambda");

    rotation_param.append("input")
            .attr("type", "range")
            .attr("id","form_projection_center")
            .attr("value", 0).attr("min", -180)
            .attr("max", 180).attr("step", 1)
            .style("vertical-align", "middle")
            .on("input", function(){
                handle_proj_center_button([this.value, null, null]);
                document.getElementById("proj_center_value_txt").innerHTML = this.value;
            });

    rotation_param.append("span")
            .attr("id", "proj_center_value_txt")
            .style("cursor", "pointer")
            .html("0")
            .on("click", handleProjTxtChange);

    rotation_param.append("span")
            .html("°");

    section5.append("div")
            .style("text-align", "center")
            .insert("button")
            .attr("id","reset_center_rotation")
            .attr("class", "button_st4 i18n")
            .attr("data-i18n", "[html]app_page.section5.reset")
            .on("click", function(){
                // Todo : improve the behavior of this button
                // Reset the rotation :
                proj.scale(0).translate(0,0);
                document.getElementById('form_projection_center').value = 0;
                document.getElementById('form_rotate').value = 0;
                document.getElementById('proj_center_value_txt').innerHTML = "0";
                proj.rotate([0,,]);
                reproj_symbol_layer();
                rotate_global(0);

                // Reset the projection :
                setSelected(document.getElementById("form_projection"), document.getElementById("form_projection").options[0].value);
                let layer_name = Object.getOwnPropertyNames(user_data)[0] || Object.getOwnPropertyNames(result_data)[0] || null;
                if(layer_name){
                    center_map(layer_name);
                    zoom_without_redraw();
                } else {
                    svg_map.__zoom = d3.zoomIdentity.scale(0.5).translate(400, 250);
                    zoom_without_redraw();
                }
            });

    let background = map.append("g")
                        .attrs({id: "Simplified_land_polygons", class: "layer"})
                        .style("stroke-width", "0.3px");

   d3.json("/static/data_sample/simplified_land_polygons.topojson", function(error, json) {
        background.selectAll('.subunit')
                  .data(topojson.feature(json, json.objects.simplified_land_polygons).features)
                  .enter()
                  .append('path')
                  .attr("d", path)
                  .styles({stroke: "rgb(0,0,0)", fill: "lightgrey", "stroke-opacity": 0.0, "fill-opacity": 0.75});
        map.selectAll("path").attr("d", path);
        scale_to_lyr("Simplified_land_polygons");
        center_map("Simplified_land_polygons");
        zoom_without_redraw();
    });

    let p = dv5.append("select")
                .attr("id","form_projection")
                .style("align", "center")
                .on("change", function(){
                    current_proj_name = this.selectedOptions[0].textContent;
                    change_projection(this.value);
                    let layer_name = Object.getOwnPropertyNames(user_data)[0] || Object.getOwnPropertyNames(result_data)[0] || null;
                    if(layer_name){
                        center_map(layer_name);
                        zoom_without_redraw();
                    }
                });
    d3.json("/static/json/projections.json", function(json) {
       json.forEach(function(d) {
            available_projections.set(d.name, d.projection);
            p.append("option").text(d.name).attr("value", d.projection);
           });
        if(window.location.search && window.location.search.indexOf("resume") > -1){
            let old_url = "modules?resume",
                new_url = "modules";
            // First avoid to let the "?resume" part in the url:
            if (typeof (history.pushState) != "undefined") {
                var obj = {Page: old_url, Url: new_url};
                history.pushState(obj, obj.Page, obj.Url);
            }

            // Fetch the last snapchot in localStorage :
            var json_params = window.localStorage.getItem("noname_map_project");

            // Apply the preferences :
            if(json_params){
                apply_user_preferences(json_params);
            }
        } else {
            // If we don't want to resume from the last project, we can
            // remove it :
            window.localStorage.removeItem("noname_app_project");
        }
    });

    let const_options = d3.select(".header_options").append("div").attr("id", "const_options").style("display", "inline")
    const_options.append("button").attr("class", "const_buttons")
              .attr("title", "Export your composition")
              .style("cursor", "pointer")
              .html('<img src="/static/img/Wikiversity-Mooc-Icon-Download_modif.png" width="20" height="20" alt="Export"/>')
              .style("margin-top", "none")
              .on("click", handle_export);

    const_options.append("button").attr("class", "const_buttons")
              .attr("title", "Export / Load your map preferences")
              .style("cursor", "pointer")
              .html('<img src="/static/img/High-contrast-system-run.svg" width="20" height="20" alt="export_load_preferences"/>')
              .style("margin-top", "none")
              .on("click", function(){
                    if(document.getElementById("menu_pref"))
                        document.getElementById("menu_pref").remove();
                    else {
                        let actions = [
                            {"name": i18next.t("app_page.common.save_project_json"), "callback": save_map_template},
                            {"name": i18next.t("app_page.common.load_project_json"), "callback": load_map_template}
                            ];
                        let menu = document.createElement("div");
                        menu.style.top = "30px";
                        menu.style.right = "38px";
                        menu.className = "context-menu";
                        menu.id = "menu_pref";
                        let list_elems = document.createElement("ul");
                        menu.appendChild(list_elems);
                        for (let i = 0; i < actions.length; i++) {
                            let item = document.createElement("li");
                            list_elems.appendChild(item);
                            item.setAttribute("data-index",i);
                            let name = document.createElement("span");
                            name.className = "context-menu-item-name";
                            name.style.color = "#000";
                            name.textContent = actions[i].name;
                            item.appendChild(name);
                            item.onclick = function(){
                                actions[i].callback();
                                menu.remove();
                            }
                        }
                        document.querySelector("body").appendChild(menu);
                    }
                });

    const_options.append("button").attr("class", "const_buttons")
              .attr("title", "Help")
              .style("cursor", "pointer")
              .html('<img src="/static/img/High-contrast-help-browser.png" width="20" height="20" alt="export_load_preferences"/>')
              .style("margin-top", "none")
              .on("click", function(){
                  swal({
                      title: "Emergency help !",
                      text: "Write something to be searched in the documentation :",
                      input: "text",
                      showCancelButton: true,
                      closeOnConfirm: false,
                      animation: "slide-from-top",
                      inputPlaceholder: "Choropleth, Discretization, Cartogram, Export, Projection"
                   }).then(inputValue => {
                          swal("Nice!", "You wrote: " + inputValue, "success");
                    })
                });

    // Zoom-in, Zoom-out, Info, Hand-Move and RectZoom buttons (on the top of the map) :
    let lm = map_div
                .append("div")
                .attr("class", "light-menu")
                .styles({position:"absolute", right:"0px", bottom: "0px"});

    let lm_buttons = [
        {id: "zoom_out", title: i18next.t("app_page.lm_buttons.zoom-"), class: "zoom_button", html: "-"},
        {id: "zoom_in", title: i18next.t("app_page.lm_buttons.zoom+"), class: "zoom_button", html: "+"},
        {id: "info_button", title: i18next.t("app_page.lm_buttons.i"), class: "info_button", html: "i"},
        {id: "hand_button", title: i18next.t("app_page.lm_buttons.hand_button"), class: "hand_button active", html: '<img src="/static/img/Closed_Hand_thenounproject_blank.png" width="18" height="18" alt="Hand_closed"/>'},
        {id: "brush_zoom_button", class: "brush_zoom_button", title: i18next.t("app_page.lm_buttons.zoom_rect"), html: '<img src="/static/img/Inkscape_icons_zoom_fit_selection_blank.svg" width="18" height="18" alt="Zoom_select"/>'}
    ];

    let selec = lm.selectAll("input")
        .data(lm_buttons).enter()
        .append('p').style("margin", "auto")
            .insert("button")
            .attr("class", d => d.class)
            .attr("title", d => d.title)
            .attr("id", d => d.id)
            .html(d => d.html);

    // Trigger actions when buttons are clicked and set-up the initial view :
    d3.selectAll(".zoom_button").on("click", zoomClick);
    document.getElementById("info_button").onclick = displayInfoOnMove;
    document.getElementById("hand_button").onclick = handle_click_hand;
    document.getElementById("hand_button").style = "box-shadow: 2px 2px 1px black inset;";
    document.getElementById("brush_zoom_button").onclick = brush_rect;

    // Already append the div for displaying information on features,
    // setting it currently unactive until it will be requested :
    d3.select("body").append("div")
                  .attr("id", "info_features")
                  .classed("active", false)
                  .style("display", "none")
                  .html("");

    create_li_layer_elem("Simplified_land_polygons", null, "Polygon", "sample");
    prepare_drop_section();

    d3.select("#header")
        .insert("span")
        .attr("id", "current_app_lang")
        .style("position", "absolute")
        .style("color", "white")
        .style("font-size", "14px")
        .style("left", "365px")
        .html(i18next.language)
        .on("click", function(){
            if(document.getElementById("menu_lang"))
                document.getElementById("menu_lang").remove();
            else {
                let current_lang = i18next.language;
                let other_lang = current_lang == "en" ? "fr" : "en"
                let actions = [
                    {"name": current_lang, "callback": change_lang},
                    {"name": other_lang, "callback": change_lang}
                    ];
                let menu = document.createElement("div");
                menu.style.top = "30px";
                menu.style.left = "360px";
                menu.className = "context-menu";
                menu.id = "menu_lang";
                menu.style.minWidth = "30px";
                menu.style.background = "#173a50";
                let list_elems = document.createElement("ul");
                menu.appendChild(list_elems);
                for (let i = 0; i < actions.length; i++) {
                    let item = document.createElement("li");
                    list_elems.appendChild(item);
                    item.setAttribute("data-index", i);
                    let name = document.createElement("span");
                    name.className = "context-menu-item-name";
                    name.style.color = "white";
                    name.textContent = actions[i].name;
                    item.appendChild(name);
                    item.onclick = function(){
                        actions[i].callback();
                        menu.remove();
                    }
                }
                document.querySelector("body").appendChild(menu);
            }

        });

    /////////////////////////////////////////////////////////////////////////////
    // JQuery menu, tooltips and progress bar related functions :
    //////////////////////////////////////////////////////////////////////////////

    // Set-up all the accordions :
    $(".accordion").accordion({ collapsible: true, active: false, heightStyle: "#map" });

    // Start with the first always opened and open the two accordions
    // on which we can drop files if they are closed when
    // we are starting to drag a file in this direction:
    $("#accordion1").accordion({active: 0, event: "click dragenter"});
    $("#accordion3").accordion("option", "event", "click dragenter")

    // Close the functionnality options accordion when the user intend to choose another function :
    $("#accordion2_pre").on("accordionbeforeactivate", function(){
    //$("#accordion2_pre").on("accordionbeforeactivate", function(event, ui){
     //   if(ui.newHeader.length) $("#accordion2").accordion({active: false})
        let section2_accordion = document.getElementById("accordion2").firstChild;
        if(section2_accordion.getAttribute("aria-expanded") == "true")
            section2_accordion.dispatchEvent(new Event("click"));
        });

    // Compute the total size occuped by the menu in order to close some section(s) to avoid go further than the page height :
    $(".accordion").on("accordionactivate", function(event, ui){
            if(!(ui.newPanel) || ui.newPanel.length == 0 )
                return ;
            let last_opened = ui.newPanel[0].parentElement.id;
            let opened = [];
            let accordions = document.querySelectorAll(".accordion");
            let new_size = 33; // Use the real header size instead of 33
            for(let i = 0; i < accordions.length ; i++){
                new_size = new_size + accordions[i].getBoundingClientRect().height;
                if(accordions[i].firstChild.getAttribute("aria-expanded") == "true")
                    opened.push(accordions[i].id);
            }
            opened.splice(opened.indexOf(last_opened), 1);
            if(new_size > window.innerHeight
                    && opened.indexOf("accordion1") > -1
                    && last_opened != "accordion1"){
                new_size = new_size - accordions[0].getBoundingClientRect().height;
                opened.splice(opened.indexOf("accordion1"), 1);
                $("#accordion1").accordion("option", "active", 1);
            }
            for(let i = opened.length - 1; i > 0; --i){
                if(new_size < window.innerHeight)
                    break;
                let acc = document.getElementById(opened[i]);
                new_size = new_size - acc.getBoundingClientRect().height;
                $("#" + opened[i]).accordion("option", "active", 1);
                opened.pop();
            }
        });

    // Set up the widget allowing to sort layers :
    $( "#sortable" ).sortable({
        placeholder: "ui-state-highlight",
        update: function(a){
          // Set the layer order on the map in concordance with the user changes
          // in the layer manager with a pretty rusty sorting algorythm
          // trying to match the requested order from the actual order
          // (currently havent been tested on a really large number of layers)
          let at_end = null;
          if(document.getElementById("info_features").className == "active"){
            displayInfoOnMove();
            at_end = true;
          }
          let desired_order = [],
              actual_order = [],
              layers = svg_map.querySelectorAll(".layer");

          for(let i=0, len_i = a.target.childNodes.length; i < len_i; i++){
              let n = a.target.childNodes[i].getAttribute("layer_name");
              desired_order[i] = n;
              actual_order[i] = layers[i].id;
          }
          for(let i = 0, len = desired_order.length; i < len; i++){
              let lyr1 = document.getElementById(desired_order[i]),
                  lyr2 = document.getElementById(desired_order[i+1]) || document.getElementById(desired_order[i]);
              svg_map.insertBefore(lyr2, lyr1);
          }
         if(at_end) displayInfoOnMove();
         }
      });
    $( "#sortable" ).disableSelection();

    // Display a progress bar during the ajaxRequest
    // (can be unset locally by using the `"global": false` param when making an ajax request)
    $(document).ajaxStart(function() {
            document.getElementById("overlay").style.display = "";
        }).ajaxComplete(function() {
            document.getElementById("overlay").style.display = "none";
    });
}

function bindTooltips(){
    // bind the mains tooltips
    $("#section1[data-tooltip!='']").qtip({
        content: { attr: "data-tooltip" },
        style: { classes: 'qtip-youtube qtip-section1' },
        position: { my: 'center left', at: 'center right', target: this }
    });

    $("#section3[data-tooltip!='']").qtip({
        content: { attr: "data-tooltip" },
        style: { classes: 'qtip-youtube qtip-section3' },
        position: { my: 'center left', at: 'center right', target: this }
    });
}


function make_eye_button(state){
    if(state == "open"){
        let eye_open = document.createElement("img");
        eye_open.setAttribute("src", "/static/img/b/eye_open.svg");
        eye_open.setAttribute("class", "active_button")
        eye_open.setAttribute("id", "eye_open");
        eye_open.setAttribute("width", 17);
        eye_open.setAttribute("height", 17);
        eye_open.setAttribute("alt", "Visible");
        return eye_open;
    } else if (state == "closed"){
        let eye_closed = document.createElement("img");
        eye_closed.setAttribute("src", "/static/img/b/eye_closed.svg");
        eye_closed.setAttribute("class", "active_button");
        eye_closed.setAttribute("id", "eye_closed");
        eye_closed.setAttribute("width", 17);
        eye_closed.setAttribute("height", 17);
        eye_closed.setAttribute("alt", "Not visible");
        return eye_closed;
    }
}

function change_lang(){
    let new_lang = this.name;
    if(new_lang == i18next.language){
        return;
    } else {
        let other_lang = new_lang == "fr" ? "en" : "fr";
        //i18next.changeLanguage(new_lang, () => { $(".i18n").localize();});
        i18next.changeLanguage(new_lang, () => {
            localize(".i18n");
            $("#section1[data-tooltip!='']").qtip("destroy", true);
            $("#section3[data-tooltip!='']").qtip("destroy", true);
            bindTooltips();
        });
        document.getElementById("current_app_lang").innerHTML = new_lang;
        let menu = document.getElementById("menu_lang");
        if(menu)
            menu.remove();
    }
}


function make_ico_choice(){
    let list_fun_ico = ['icon_prop.png',
                        'icon_choro.png',
                        'icon_typo.png',
                        'icon_choroprop.png',
                        'icon_flow.png',
                        'icon_grid.png',
                        'icon_cartogram.png',
                        'icon_smooth.png',
                        'icon_discont.png',
                        'icon_typosymbol.png',
                        'icon_label.png'];
    let function_panel = section2_pre.append("p")
                            .style("text-align", "center")
                            .style("margin-top", "1px")
                            .style("margin-bottom", "1px");
    for(let i = 0, len_i = list_fun_ico.length; i < len_i; i++){
        let ico_name = list_fun_ico[i],
            func_name = ico_name.split('.')[0].split("_")[1],
            func_desc = get_menu_option(func_name).desc;
        function_panel.append("img")
            .attr("title", i18next.t(["app_page.func_description.", func_name].join('')))
            .attr("src", ["/static/img/func_icons/", ico_name].join(''))
            .style("margin", "1px")
            .style("cursor", "pointer")
            .on("click", function(){
                if(window.fields_handler){
                    fields_handler.unfill();
                }
                current_functionnality = get_menu_option(func_name);
                let make_menu = eval(current_functionnality.menu_factory);
                window.fields_handler = eval(current_functionnality.fields_handler);
                // Replace the title of the section without touching the triangle icon from the menu:
                let selec_title = document.getElementById("accordion2").querySelector("h3");
                selec_title.innerHTML = selec_title.innerHTML.replace(selec_title.innerText, current_functionnality.title);
                clean_menu_function();
                make_menu();

                $("#btn_info[data-tooltip_help!='']").qtip({
                    content: {text: i18next.t("app_page.func_help." + func_name + ".block"),
                              title: i18next.t("app_page.func_help." + func_name + ".title") },
                    style: { classes: 'qtip-tipped qtip_help' },
                    position: { my: 'top left', at: 'center right', target: this },
                    hide: { fixed: true }
                });

                if(targeted_layer_added){
                    let target_layer = Object.getOwnPropertyNames(user_data)[0];
                    fields_handler.fill(target_layer);
                }
                if(func_name == "flow" && joined_dataset){
                    fields_handler.fill();
                }
                switch_accordion_section("accordion2_pre", "accordion2");
            });
    }
}

var w = Math.round(window.innerWidth - 360),
    h = window.innerHeight - 75;
    //h = Math.round(window.innerHeight / 1.24);

var existing_lang = ["en", "fr"];

var proj = d3.geoNaturalEarth().scale(1).translate([0,0]);

var path = d3.geoPath().projection(proj).pointRadius(4),
    t = proj.translate(),
    s = proj.scale(),
    current_proj_name = "Natural Earth",
    available_projections = new Map(),
    zoom = d3.zoom().on("zoom", zoom_without_redraw),
    sample_no_values = new Set(["Sphere", "Graticule", "Simplified_land_polygons"]);

/*
A bunch of global variable, storing oftently reused informations :
    - user_data[layer_name] : will be an Array of Objects containing data for each features of the targeted layer
            (+ the joined features if a join is done)
    - result_data[layer_name] : the same but for any eventual result layers (like Stewart, gridded, etc.)
    - joined_dataset : the joined dataset (read with d3.csv then pushed in the first slot of this array)
    - field_join_map : an array containg mapping between index of geom layer and index of ext. dataset
    - current_layers : the main object describing **all** the layers on the map (incunding detailed (ie. by features) styling properties if needed)
    - last_params : an object to fill with the last user selected paremeter after "valid" button of
            the targeted functionnality has been pushed
*/

var user_data = new Object(),
    result_data = new Object(),
    joined_dataset = [],
    field_join_map  = [],
    targeted_layer_added = false,
    current_layers = new Object(),
    last_params = new Object(),
    dataset_name = undefined,
    join_button = null,
    canvas_rotation_value = undefined,
    map_div = d3.select("#map"),
    current_functionnality = undefined;

// The "map" (so actually the `map` variable is a reference to the main `svg` element on which we are drawing)
var map = map_div.style("width", w+"px").style("height", h+"px")
            .append("svg")
                .attr("id", "svg_map")
                .attr("width", w)
                .attr("height", h)
                .style("position", "absolute")
                .call(zoom);

var brush;

// A bunch of references to the buttons used in the layer manager
// and some mapping to theses reference according to the type of geometry :
var button_style = ' <img src="/static/img/High-contrast-edit-clear.png" class="style_button" width="17" height="17" alt="submit"/>',
    button_trash = ' <img src="/static/img/Trash_font_awesome.png" id="trash_button" width="17" height="17" alt="submit"/>',
    button_legend = ' <img src="/static/img/qgis_legend.png" id="legend_button" width="17" height="17" alt="submit"/>',
    button_zoom_fit = ' <img src="/static/img/Inkscape_icons_zoom_fit_page.png" id="zoom_fit_button" width="17" height="17" alt="submit"/></button>',
    button_type = new Map([
        ["Point", '<img src="/static/img/type_geom/dot.png" class="ico_type" width="17" height="17" alt="Point"/>'],
        ["Line", '<img src="/static/img/type_geom/line.png" class="ico_type" width="17" height="17" alt="Line"/>'],
        ["Polygon", '<img src="/static/img/type_geom/poly.png" class="ico_type" width="17" height="17" alt="Polygon"/>']
        ]);

var button_result_type = new Map([
        ["flow", '<img src="/static/img/type_geom/layer_flow.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["symbol", '<img src="/static/img/type_geom/layer_symbol.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["grid", '<img src="/static/img/type_geom/layer_grid.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["MTA", '<img src="/static/img/type_geom/layer_mta.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["propchoro", '<img src="/static/img/type_geom/layer_propchoro.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["typo", '<img src="/static/img/type_geom/layer_typo.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["discont", '<img src="/static/img/type_geom/layer_disc.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["cartogram", '<img src="/static/img/type_geom/layer_cartogram.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["label", '<img src="/static/img/type_geom/layer_label.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["choro", '<img src="/static/img/type_geom/layer_choro.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["smooth", '<img src="/static/img/type_geom/layer_smooth.svg" class="ico_type" width="17" height="17" alt="Polygon"/>'],
        ["prop", '<img src="/static/img/type_geom/layer_prop.svg" class="ico_type" width="17" height="17" alt="Polygon"/>']
        ]);

var eye_open0 = '<img src="/static/img/b/eye_open.svg" class="active_button" id="eye_open"  width="17" height="17" alt="Visible"/>';

// Reference to the sys run button already in two requested sizes are they are called many times :
var sys_run_button = '<img src="/static/img/High-contrast-system-run.svg" width="22" height="22" style="vertical-align: inherit;" alt="submit"/>',
    sys_run_button_t2 = '<img src="/static/img/High-contrast-system-run.svg" class="style_target_layer" width="16" height="16" alt="Layer_rendering" style="float:right;margin-top:4px;"/>';

// Reference to the availables fonts that the user could select :
var available_fonts = [
    ['Arial', 'Arial,Helvetica,sans-serif'],
    ['Arial Black', 'Arial Black,Gadget,sans-serif'],
    ['Arimo', 'Arimo,sans-serif'],
    ['Bitter', 'Bitter,sans-serif'],
    ['Dosis', 'Dosis,sans-serif'],
    ['Humor Sans', 'Humor Sans'],
    ['Roboto', 'Roboto,sans-serif'],
    ['Lobster', 'Lobster,sans-serif'],
    ['Impact', 'Impact,Charcoal,sans-serif'],
    ['Georgia', 'Georgia,serif'],
    ['Lucida', 'Lucida Sans Unicode,Lucida Grande,sans-serif'],
    ['Palatino', 'Palatino Linotype,Book Antiqua,Palatino,serif'],
    ['Tahoma', 'Tahoma,Geneva,sans-serif'],
    ['Trebuchet MS', 'Trebuchet MS, elvetica,sans-serif'],
    ['Verdana', 'Verdana,Geneva,sans-serif']
    ];


current_layers["Simplified_land_polygons"] = {"type": "Polygon", "n_features":125, "stroke-width-const": 0.3, "fill_color": {single: "#d3d3d3"}};

{% raw %}

(function(){
    let lang = window.navigator.language.split('-')[0];
    lang = existing_lang.indexOf(lang) > -1 ? lang : 'en';
    i18next.use(i18nextXHRBackend)
      .init({
          debug: true,
          lng: lang,
          fallbackLng: existing_lang[0],
          backend: {
            loadPath: "/static/locales/{{lng}}/translation.json"
          }
    }, (err, t) => {
        if(err)
            throw err;
        else {
            window.localize = locI18next.init(i18next);
            //jqueryI18next.init(i18next, $);
            setUpInterface();
            localize(".i18n");
            bindTooltips();
            //$(".i18n").localize();
        }
    });
})();

{% endraw %}

function up_legend(){
    let legend_features = svg_map.querySelectorAll('.legend');
    for(let i = 0; i < legend_features.length; i++){
        svg_map.appendChild(legend_features[i], null);
    }
    let defs = document.querySelector("defs");
    if(defs && svg_map.childNodes[0].tagName != "defs"){
        svg_map.insertBefore(defs, svg_map.childNodes[0]);
    }
}

////////////////
// To sort:
////////////////

// To bind the set of small buttons (trash icon, paint icon, active/deactive visibility, info tooltip, etc..)
// which are on each feature representing a layer in the layer manager
// (the function is called each time that a new feature is put in this layer manager)
function binds_layers_buttons(layer_name){
    if(layer_name == undefined){
        alert("This shouldn't happend");
        return;
    }
    let sortable_li_elem = d3.select("#sortable").select("." + layer_name);
    sortable_li_elem.select("#trash_button").on("click", function(){ remove_layer(layer_name); });
    sortable_li_elem.select(".active_button").on("click", function(){ handle_active_layer(layer_name); });
    sortable_li_elem.select("#zoom_fit_button").on("click", function(){
        center_map(layer_name);
        zoom_without_redraw();
    });
    sortable_li_elem.select(".style_button").on("click", function(){
        handle_click_layer(layer_name);
    });
    sortable_li_elem.select(".style_target_layer").on("click", function(){
        handle_click_layer(layer_name)
    });
    sortable_li_elem.select("#legend_button").on("click", function(){
        handle_legend(layer_name);
    });

    $("[layer-tooltip!='']").qtip({
        content: { attr: "layer-tooltip" },
        style: { classes: 'qtip-rounded qtip-light qtip_layer'}
    });
}

// Function to display information on the top layer (in the layer manager)
// it will only works on layers appearing in blue in the layer manager
// (ie. the targeted layer and result(s?) layer(s?))
function displayInfoOnMove(){
    var info_features = d3.select("#info_features");
    if(info_features.classed("active")){
        d3.select(".info_button").style('box-shadow', null);
        map.selectAll("path").on("mouseover", null);
        map.selectAll("circle").on("mouseover", null);
        map.selectAll("rect").on("mouseover", null);
        info_features.classed("active", false);
        info_features.node().innerHTML = "";
        info_features.style("display", "none");
        document.getElementById("map").style.cursor="";
    } else {
        let layers = document.querySelectorAll(".layer"),
            nb_layer = layers.length,
            top_visible_layer = null;

        for(let i = nb_layer-1; i > -1; i--){
            if(layers[i].style.visibility != "hidden"){
                top_visible_layer = layers[i].id
                break;
            }
        }

        if(!top_visible_layer){
            swal("", "Error : no visible layer found", "error");
            return;
        }

        let id_top_layer = "#" + top_visible_layer,
            symbol = current_layers[top_visible_layer].symbol;

        d3.select(".info_button").style('box-shadow', 'inset 2px 2px 1px black');
        if(symbol){
            let ref_layer_name = current_layers[top_visible_layer].ref_layer_name;
            map.select(id_top_layer).selectAll(symbol).on("mouseover", function(d,i){
                //let ref_id = current_layers[top_visible_layer].features_order ? current_layers[top_visible_layer].features_order[i][0] : +i;
                //let txt_info = ["<h3>", top_visible_layer, "</h3><i>Feature ",
                //                ref_id + 1, "/", current_layers[ref_layer_name].n_features, "</i><p>"];
                //let properties = user_data[ref_layer_name][ref_id];
                let txt_info = ["<h3>", top_visible_layer, "</h3><i>Feature ",
                                i + 1, "/", current_layers[top_visible_layer].n_features, "</i><p>"];
                let properties = result_data[top_visible_layer][i];
                Object.getOwnPropertyNames(properties).forEach(function(el, i){
                    txt_info.push("<br><b>"+el+"</b> : "+properties[el]);
                    });
                txt_info.push("</p>");
                info_features.node().innerHTML = txt_info.join('');
                info_features.style("display", null);
                });
        } else {
            symbol = "path"
            map.select(id_top_layer).selectAll("path").on("mouseover", function(d,i){
                let txt_info = ["<h3>", top_visible_layer, "</h3><i>Feature ",
                                i + 1, "/", current_layers[top_visible_layer].n_features, "</i><p>"];
                Object.getOwnPropertyNames(d.properties).forEach(function(el, i){
                    txt_info.push("<br><b>"+el+"</b> : "+d.properties[el]);
                    });
                txt_info.push("</p>");
                info_features.node().innerHTML = txt_info.join('');
                info_features.style("display", null);
                });
        }
        map.select(id_top_layer).selectAll(symbol).on("mouseout", function(){
                info_features.node().innerHTML = "";
                info_features.style("display", "none");
        });
        info_features.classed("active", true);
        document.getElementById("map").style.cursor="help";
    }
}

function reproj(){
  proj.translate([t[0], t[1]]).scale(s);
  map.selectAll("path").attr("d", path);
  reproj_symbol_layer();
}

function reproj_symbol_layer(){
  for(let lyr_name in current_layers){
    if(current_layers[lyr_name].renderer
        && (current_layers[lyr_name].renderer.indexOf('PropSymbol') > -1
            || current_layers[lyr_name].renderer.indexOf('TypoSymbols')  > -1
            || current_layers[lyr_name].renderer.indexOf('Label')  > -1 )){
      let ref_layer_name = current_layers[lyr_name].ref_layer_name,
          features_order = current_layers[lyr_name].features_order,
          symbol = current_layers[lyr_name].symbol,
          new_coords = new Array();
      map.select("#" + ref_layer_name)
            .selectAll("path")
            .each((d,i) => {
                new_coords.push(path.centroid(d))
            });

      if (symbol == "text") {
          map.select("#"+lyr_name)
                .selectAll(symbol)
                .attr("x", (d,i) => new_coords[i][0])
                .attr("y", (d,i) => new_coords[i][1])
      } else if (symbol == "image"){
          map.select("#"+lyr_name)
                .selectAll(symbol)
                .attr("x", function(d,i){ console.log(this); return new_coords[i][0] - +this.getAttribute("width").slice(0, -2) / 2; })
                .attr("y", function(d,i){ return new_coords[i][1] - +this.getAttribute("width").slice(0, -2) / 2; })
      } else {
          let ord = features_order.map(obj => obj[0]);
          for(let i = 0; i < ord.length; i++)
            features_order[i][2] = new_coords[ord[i]];

          if(symbol == "circle")
              map.select("#"+lyr_name)
                    .selectAll(symbol)
                    .attr("cx", (d,i) => features_order[i][2][0])
                    .attr("cy", (d,i) => features_order[i][2][1])
                    .attr("r", (d,i) => features_order[i][1]);
          else if (symbol == "rect")
              map.select("#"+lyr_name)
                    .selectAll(symbol)
                    .attr("x", (d,i) => features_order[i][2][0] - features_order[i][1] / 2)
                    .attr("y", (d,i) => features_order[i][2][1] - features_order[i][1] / 2)
                    .attr("height", (d,i) => features_order[i][1])
                    .attr("width", (d,i) => features_order[i][1]);
      }
    }
  }
}

// Convenience function to make a confirm dialog returning a defered promise
// which can be used like `myConfirmDialog("Confirm", "ok", "cancel").then(function(confirmed){if(confirmed){ ... }})
var make_confirm_dialog = function(html_content, text_ok, text_cancel, title, class_box, width, height, top){
    html_content = html_content || "";
    text_ok = text_ok || "Ok";
    text_cancel = text_cancel || i18next.t("app_page.common.cancel");
    title = title || i18next.t("app_page.common.confirm");
    class_box = class_box || "dialogBox";
    var deferred = Q.defer();
    d3.select("body").append("div")
        .attr("id", "dialog").attr("class", class_box)
        .attr("title", title).html(html_content);

    $( "#dialog" ).dialog({
        position: top ? { my: "center", at: "top" } : undefined, width: width, height: height, modal:true,
        buttons:[
           {
            text: text_ok,
            click: function(){ deferred.resolve(true); $(this).dialog("close"); }
                },
           {
            text: text_cancel,
            click: function(){ $(this).dialog("close"); $(this).remove(); }
           }],
        close: function(event, ui){
                $(this).dialog("destroy").remove();
                if(deferred.promise.isPending())
                    deferred.resolve(false);
            }
      });
    return deferred.promise;
};

// Wrapper to obtain confirmation before actually removing a layer :
function remove_layer(name){
    name = name || this.parentElement.parentElement.getAttribute("layer_name");
    swal({
        title: "",
        text: i18next.t("app_page.common.remove_layer", {layer: name}),
        type: "warning",
        showCancelButton: true,
        allowOutsideClick: false,
        confirmButtonColor: "#DD6B55",
        confirmButtonText: "Delete!",
        closeOnConfirm: true
    }).then(() => { remove_layer_cleanup(name); },
            () => { null; }
    );    // ^^^^^^^^^^^^ Do nothing on cancel, but this avoid having an "uncaught exeption (cancel)" comming in the console if nothing is set here
                //  ^^^^^^^^^^^^^^^^^^^^^^^ Not sure anymore :/
}

function remove_ext_dataset(){
    swal({
        title: "",
        text: i18next.t("app_page.common.remove_tabular"),
        type: "warning",
        showCancelButton: true,
        allowOutsideClick: false,
        confirmButtonColor: "#DD6B55",
        confirmButtonText: i18next.t("app_page.common.delete") + "!",
        closeOnConfirm: true
        }).then(() => {
            remove_ext_dataset_cleanup();
        }, () => { null; });
}

function remove_ext_dataset_cleanup(){
    field_join_map = new Array();
    joined_dataset = new Array();
    dataset_name = undefined;
    let ext_dataset_img = document.getElementById("img_data_ext");
    ext_dataset_img.setAttribute("src", "/static/img/b/addtabular.svg");
    ext_dataset_img.setAttribute("alt", "Additional dataset");
    ext_dataset_img.style.cursor = "pointer";
    ext_dataset_img.onclick = click_button_add_layer;
    let data_ext_txt = document.getElementById("data_ext");
    data_ext_txt.innerHTML = "<b>" + i18next.t("app_page.section1.add_ext_dataset") + "</b>";
    data_ext_txt.onclick = click_button_add_layer;
    document.getElementById("remove_dataset").remove();
    document.getElementById("join_section").innerHTML = "";
    document.getElementById('sample_zone').style.display = null;
    if(Object.getOwnPropertyNames(user_data).length == 0){
        document.getElementById("browse_button").disabled = true;
    }
    $("#data_ext").qtip("destroy");
}

// Do some clean-up when a layer is removed
// Most of the job is to do when it's the targeted layer which is removed in
// order to restore functionnalities to their initial states
function remove_layer_cleanup(name){
     let g_lyr_name = "#"+name;

     // Making some clean-up regarding the result layer :
    if(current_layers[name].is_result){
        d3.selectAll([".lgdf_", name].join('')).remove();
        if(result_data.hasOwnProperty(name))
            delete result_data[name];
        if(current_layers[name].hasOwnProperty("key_name")
           && current_layers[name].renderer.indexOf("Choropleth") < 0
           && current_layers[name].renderer.indexOf("Categorical") < 0)
            send_remove_server(name);
    }

    // Remove the layer from the map and from the layer manager :
    map.select(g_lyr_name).remove();
    document.querySelector('#sortable .' + name).remove()

    // Reset the panel displaying info on the targeted layer if she"s the one to be removed :
    if(current_layers[name].targeted){
        // Updating the top of the menu (section 1) :
        $("#input_geom").qtip("destroy");
        d3.select("#img_in_geom")
            .attrs({"id": "img_in_geom", "class": "user_panel", "src": "/static/img/b/addgeom.png", "width": "24", "height": "24",  "alt": "Geometry layer"})
            .on('click',  click_button_add_layer);
        d3.select("#input_geom").html("<b>" + i18next.t("Add geometry layer") + " <i>" + i18next.t("(or drop it)") + "</i></b>")
            .on('click', click_button_add_layer);
        document.getElementById("remove_target").remove();
        // Unfiling the fields related to the targeted functionnality:
        if(current_functionnality)
            fields_handler.unfill()

        // Update some global variables :
        field_join_map = [];
        user_data = new Object();
        targeted_layer_added = false;

        // Redisplay the bottom of the section 1 in the menu allowing user to select a sample layer :
        document.getElementById('sample_zone').style.display = null;

        // Restore the state of the bottom of the section 1 :
        d3.select("#join_section").html("");

        // If after this removal there isn't nor a targeted layer neither an external dataset :
        if(joined_dataset.length == 0)
            document.getElementById("browse_button").disabled = true;
    }

    // There is probably better ways in JS to delete the object,
    // but in order to make it explicit that we are removing it :
    delete current_layers[name];
}

function load_map_template(){
    let input_button = d3.select(document.createElement('input'))
                    .attr("type", "file").attr("name", "file")
                    .attr("enctype", "text/json")
                    .on('change', function(){ prepareReading(d3.event) });

    let prepareReading = function(event){
        let file = event.target.files[0],
            reader = new FileReader();
        reader.onloadend = function(){ apply_user_preferences(reader.result); }
        reader.readAsText(file);
    }

    input_button.node().dispatchEvent(new MouseEvent("click"))
}

// Change color of the background (ie the parent "svg" element on the top of which group of elements have been added)
function handle_bg_color(color){
    map.style("background-color", color);
}

function handle_click_hand(){
    var hb = d3.select('.hand_button');
    if(hb.classed("active")){
        hb.style('box-shadow', "none").classed("active", false);
        zoom.on("zoom", null);
    } else {
        hb.style('box-shadow', 'inset 2px 2px 1px black').classed("active", true);
        zoom.on("zoom", zoom_without_redraw);
        map.on("mousemove.zoomRect", null).on("mouseup.zoomRect", null);
    }
}

function brush_action() {
    var s = d3.event.selection;
    if(!s){
        return;
    }
    console.log(s);

    var x0 = s[0][0],
        y0 = s[0][1],
        dx = s[1][0],
        dy = s[1][1];
    var _zoom = svg_map.__zoom;

    s = [proj.invert([x0, y0]), proj.invert([dx, dy])]
    let zoom_scale = .95 / Math.max((s[1][0] - s[0][0]) / w, (s[1][1] - s[0][1]) / h);
    let new_zoom = d3.zoomIdentity.scale(zoom_scale).translate((s[1][0] + s[0][0]) / 2, (s[1][1] + s[0][1]) / 2)

    let zoom_translate = [(w - zoom_scale * (s[1][0] + s[0][0])) / 2, (h - zoom_scale * (s[1][1] + s[0][1])) / 2];
    console.log(new_zoom)
    _zoom.k = new_zoom.k
    _zoom.x = new_zoom.x
    _zoom.y = new_zoom.y
    map.select(".brush").remove();
    brush = null;
    zoom_without_redraw();
}


function brush_rect(){
    let zoom_brush_button = d3.select(".brush_zoom_button"),
        hb = d3.select('.hand_button');
    if(zoom_brush_button.classed("active")){
        zoom_brush_button.style('box-shadow', "none").classed("active", false);
        map.select(".brush").remove();
    } else {
        brush = d3.brush()
            .on("end", brush_action);
        zoom_brush_button.style('box-shadow', 'inset 2px 2px 1px black').classed("active", true);
        map.append("g")
            .attr("class", "brush")
            .call(brush);
    }
}

function get_map_template(){
    var map_config = new Object(),
        layers_style = [],
        layers = map.selectAll("g.layer"),
        map_title = document.getElementById('map_title'),
        displayed_legend = d3.selectAll(".legend_feature:not(.title)"),
        zoom_transform = d3.zoomTransform(svg_map);

    map_config.projection = current_proj_name;
    map_config.projection_scale = proj.scale();
    map_config.projection_translate = proj.translate();
    map_config.projection_center = proj.center();
    map_config.projection_rotation = proj.rotate();
    map_config.zoom_translate = [zoom_transform.x, zoom_transform.y];
    map_config.zoom_scale = zoom_transform.k;
    map_config.div_width = +w;
    map_config.div_height = +h;
    map_config.n_layers = layers._groups[0].length;
    map_config.displayed_legend = displayed_legend.size() > 0 ? true : false;

    if(map_title){
        map_config.title = {
            "content": map_title.textContent,
            "x": map_title.getAttribute("x"),
            "y": map_title.getAttribute("y"),
            "style": map_title.getAttribute("style")
            };
    }

    for(let i=map_config.n_layers-1; i > -1; --i){
        let layer_name = layers._groups[0][i].id,
            nb_ft = current_layers[layer_name].n_features,
            selection;

        layers_style[i] = new Object();
        layers_style[i].layer_name = layer_name;
        layers_style[i].n_features = nb_ft;

        if(current_layers[layer_name]["stroke-width-const"])
            layers_style[i]["stroke-width-const"] = current_layers[layer_name]["stroke-width-const"];

        if(current_layers[layer_name].fixed_stroke)
            layers_style[i].fixed_stroke = current_layers[layer_name].fixed_stroke;

        if(current_layers[layer_name].colors_breaks)
            layers_style[i].colors_breaks = JSON.stringify(current_layers[layer_name].colors_breaks);

        if (current_layers[layer_name].targeted){
            selection = map.select("#" + layer_name).selectAll("path");
            layers_style[i].fill_opacity = selection.style("fill-opacity");
            layers_style[i].targeted = true;
            layers_style[i].topo_geom = String(current_layers[layer_name].key_name);
            layers_style[i].fill_color = current_layers[layer_name].fill_color;
        } else if(!current_layers[layer_name].renderer){
            selection = map.select("#" + layer_name).selectAll("path");
        } else if(current_layers[layer_name].renderer.indexOf("PropSymbols") > -1){
            let type_symbol = current_layers[layer_name].symbol;
            selection = map.select("#" + layer_name).selectAll(type_symbol);
            layers_style[i].symbol = type_symbol;
            layers_style[i].rendered_field = current_layers[layer_name].rendered_field;
            layers_style[i].renderer = current_layers[layer_name].renderer;
            layers_style[i].size = current_layers[layer_name].size;
            layers_style[i].fill_color = current_layers[layer_name].fill_color;
            layers_style[i].ref_layer_name = current_layers[layer_name].ref_layer_name;
            layers_style[i].features_order = JSON.stringify(current_layers[layer_name].features_order);
        } else if (current_layers[layer_name].renderer == "Stewart"
                    || current_layers[layer_name].renderer == "Gridded"
                    || current_layers[layer_name].renderer == "Choropleth"
                    || current_layers[layer_name].renderer == "Carto_doug"){
            selection = map.select("#" + layer_name).selectAll("path");
            layers_style[i].renderer = current_layers[layer_name].renderer;
            layers_style[i].topo_geom = String(current_layers[layer_name].key_name);
            layers_style[i].fill_color = current_layers[layer_name].fill_color;
            layers_style[i].rendered_field = current_layers[layer_name].rendered_field;
            layers_style[i].ref_layer_name = current_layers[layer_name].ref_layer_name;
            let color_by_id = [];
            selection.each(function(){
                color_by_id.push(rgb2hex(this.style.fill));
            });
            layers_style[i].color_by_id = color_by_id;
            layers_style[i].options_disc = current_layers[layer_name].options_disc;
        } else if (current_layers[layer_name].renderer == "Links"
                    || current_layers[layer_name].renderer == "DiscLayer"){
            selection = map.select("#" + layer_name).selectAll("path");
            layers_style[i].fill_color = current_layers[layer_name].fill_color;
            layers_style[i].topo_geom = String(current_layers[layer_name].key_name);
            layers_style[i].rendered_field = current_layers[layer_name].rendered_field;
            layers_style[i].ref_layer_name = current_layers[layer_name].ref_layer_name;
            layers_style[i].size = current_layers[layer_name].size;
            layers_style[i].min_display = current_layers[layer_name].min_display;
            if(current_layers[layer_name].renderer == "DiscLayer"){
                layers_style[i].result = new Array(nb_ft)
                for(let j = 0; j < nb_ft; j++)
                    layers_style[i].result[j] = nb_ft;
            } else {
                layers_style[i].topo_geom = String(current_layers[layer_name].key_name);
                layers_style[i].linksbyId = current_layers[layer_name].linksbyId.splice(0, nb_ft)
            }
        } else if (current_layers[layer_name].renderer == "TypoSymbols"){
            selection = map.select("#" + layer_name).selectAll("image")
            layers_style[i].symbols_map = JSON.stringify([...current_layers[layer_name].symbols_map]);
            layers_style[i].rendered_field = current_layers[layer_name].rendered_field;
            layers_style[i].ref_layer_name = current_layers[layer_name].ref_layer_name;

            let state_to_save = [];
            let selec = selection._groups[0];
            for(let i = 0; i < selec.length ; i++){
                let ft = selec[i];
                state_to_save.push({display: ft.style.display,
                                    data: ft.__data__,
                                    pos: [ft.getAttribute('x'), ft.getAttribute('y')],
                                    size: ft.getAttribute('width')
                                    });
            }
            layers_style[i].current_state = state_to_save;
        } else if(current_layers[layer_name].renderer == "Label") {
            selection = map.select("#" + layer_name).selectAll("text");
            layers_style[i].rendered_field = current_layers[layer_name].rendered_field;
            layers_style[i].contents_pos = [];
        } else {
            selection = map.select("#" + layer_name).selectAll("path");
        }
        layers_style[i].stroke_opacity = selection.style("stroke-opacity");
        layers_style[i].fill_opacity = selection.style("fill-opacity");
    }

    return Q.all(layers_style.map( obj => {return obj.topo_geom ? request_data("GET", "/get_layer/" + obj.topo_geom, null) : null}))
        .then(function(result){
            for(let i = 0; i < layers_style.length; i++){
                    if(result[i] && result[i].target){
                        layers_style[i].topo_geom = result[i].target.responseText;
                    }
                }
            console.log(JSON.stringify({"map_config": map_config, "layers": layers_style}))
            return JSON.stringify({"map_config": map_config, "layers": layers_style});;
        });
}

// Function triggered when the user request a download of its map preferences
function save_map_template(){
    get_map_template().then(
        function(json_params){
            let dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(json_params),
                dlAnchorElem = document.getElementById('downloadAnchorElem');
            dlAnchorElem.setAttribute("href", dataStr);
            dlAnchorElem.setAttribute("download", "noname_properties.json");
            dlAnchorElem.click();
    });
}

//////////////////////////////////////////////////////////////////////////////
// Zooming functions (some from http://bl.ocks.org/linssen/7352810)
//////////////////////////////////////////////////////////////////////////////

function zoom_without_redraw(){
    var rot_val = canvas_rotation_value || "";
    var transform;
    if(!d3.event || !d3.event.transform || !d3.event.sourceEvent){
        transform = d3.zoomTransform(svg_map);
        map.selectAll(".layer")
          .transition()
          .duration(50)
          .style("stroke-width", function(){
                let lyr_name = this.id;
                return current_layers[lyr_name].fixed_stroke
                        ? this.style.strokeWidth
                        : current_layers[lyr_name]['stroke-width-const'] / transform.k +  "px";
            })
          .attr("transform", transform.toString());
    } else {
        //transform = d3.event.transform;
        //let zoom_scale = +new RegExp(/scale\(([^)]+)\)/).exec(transform)[1].split(',')[0];
        map.selectAll(".layer")
                  .transition()
                  .duration(50)
                  .style("stroke-width", function(){
                        let lyr_name = this.id;
                        return current_layers[lyr_name].fixed_stroke
                                ? this.style.strokeWidth
                                : current_layers[lyr_name]['stroke-width-const'] / d3.event.transform.k +  "px";
                    })
                  .attr("transform", d3.event.transform)
    }

    if(scaleBar.displayed)
        scaleBar.update();

    if(window.legendRedrawTimeout){
        clearTimeout(legendRedrawTimeout);
    }
    window.legendRedrawTimeout = setTimeout(redraw_legends_symbols, 650);
    let zoom_params = svg_map.__zoom;
    document.getElementById("input-center-x").value = round_value(zoom_params.x, 2);
    document.getElementById("input-center-y").value = round_value(zoom_params.y, 2);
    document.getElementById("input-scale-k").value = round_value(zoom_params.k * proj.scale(), 2);
};

function redraw_legends_symbols(targeted_node){
    if(!targeted_node)
        var legend_nodes = document.querySelectorAll("#legend_root2");
    else
        var legend_nodes = [targeted_node];

    for(let i=0; i<legend_nodes.length; ++i){
        let layer_name = legend_nodes[i].classList[2].split('lgdf_')[1],
            rendered_field = current_layers[layer_name].rendered_field,
            nested = legend_nodes[i].getAttribute("nested"),
            display_value = legend_nodes[i].getAttribute("display"),
            visible = legend_nodes[i].style.visibility;

        let transform_param = legend_nodes[i].getAttribute("transform"),
            lgd_title = legend_nodes[i].querySelector("#legendtitle").innerHTML,
            lgd_subtitle = legend_nodes[i].querySelector("#legendsubtitle").innerHTML;

        let rect_fill_value = legend_nodes[i].getAttribute("visible_rect") == "true" ? {
            color: legend_nodes[i].querySelector("#under_rect").style.fill,
            opacity: legend_nodes[i].querySelector("#under_rect").style.fillOpacity
        } : undefined;

        legend_nodes[i].remove();
        createLegend_symbol(layer_name, rendered_field, lgd_title, lgd_subtitle, nested, rect_fill_value);
        let new_lgd = document.querySelector(["#legend_root2.lgdf_", layer_name].join(''));
        new_lgd.style.visibility = visible;
        new_lgd.setAttribute("display", display_value);
        if(transform_param)
            new_lgd.setAttribute("transform", transform_param);
    }
}

function interpolateZoom(translate, scale) {
    var self = this;
    var transform = d3.zoomTransform(svg_map);
    return d3.transition().duration(225).tween("zoom", function () {
        var iTranslate = d3.interpolate([transform.x, transform.y], translate),
            iScale = d3.interpolate(transform.k, scale);
        return function (t) {
            svg_map.__zoom.k = iScale(t);
            let _t =  iTranslate(t);
            svg_map.__zoom.x = _t[0];
            svg_map.__zoom.y = _t[1];
            zoom_without_redraw()
        };
    });
}

function zoomClick() {
    var clicked = d3.event.target,
        direction = 1,
        factor = 0.1,
        target_zoom = 1,
        center = [w / 2, h / 2],
        transform = d3.zoomTransform(svg_map),
        translate = [transform.x, transform.y],
        translate0 = [],
        l = [],
        view = {x: translate[0], y: translate[1], k: transform.k};

    d3.event.preventDefault();
    direction = (this.id === 'zoom_in') ? 1 : -1;
    target_zoom = transform.k * (1 + factor * direction);

    translate0 = [(center[0] - view.x) / view.k, (center[1] - view.y) / view.k];
    view.k = target_zoom;
    l = [translate0[0] * view.k + view.x, translate0[1] * view.k + view.y];

    view.x += center[0] - l[0];
    view.y += center[1] - l[1];

    interpolateZoom([view.x, view.y], view.k);
}


//////////////////////////////////////////////////////////////////////////////
// Rotation functions :
//////////////////////////////////////////////////////////////////////////////

function rotate_global(angle){
    canvas_rotation_value = ["rotate(", angle, ",", w / 2,",", h / 2, ")"].join('');

    let zoom_transform = d3.zoomTransform(svg_map);

    map.selectAll("g.layer")
      .transition()
      .duration(10)
      .attr("transform", [canvas_rotation_value,
                          ",translate(", [zoom_transform.x, zoom_transform.y], "),",
                          "scale(", zoom_transform.k, ")"].join(''));
    if(northArrow.displayed){
        let current_transform = northArrow.svg_node.attr("transform");
        if(current_transform)
            northArrow.svg_node.attr("transform", ["rotate(", angle, ",",northArrow.x,",", northArrow.y, "),"].join('') + current_transform);
        else
            northArrow.svg_node.attr("transform",  ["rotate(", angle, ",",northArrow.x,",", northArrow.y, ")"].join(''));
        }
};

function handleClipPath(proj_name){
    proj_name = proj_name.toLowerCase();
    if(proj_name.indexOf("interrupted") > -1 || proj_name.indexOf("armadillo") > -1 || proj_name.indexOf("healpix") > -1){
        let defs = document.querySelector("defs");
        if(defs){ defs.remove(); }

        defs = map.append("defs");

        defs.append("path")
            .datum({type: "Sphere"})
            .attr("id", "sphere")
            .attr("d", path);

        defs.append("clipPath")
            .attr("id", "clip")
          .append("use")
            .attr("xlink:href", "#sphere");

        map.selectAll(".layer")
            .attr("clip-path", "url(#clip)");

        svg_map.insertBefore(svg_map.querySelector("defs"), svg_map.childNodes[0]);
    } else {
        let defs = document.querySelector("defs");
        if(defs){
            defs.remove();
            map.selectAll(".layer")
                .attr("clip-path", null);
        }
    }
}

function handleClipPathLayer(layer_name){
    let _proj_name = current_proj_name.toLowerCase();
    if(_proj_name.indexOf("interrupted") > -1
        || _proj_name.indexOf("armadillo") > -1
        || _proj_name.indexOf("healpix") > -1){
            map.select("#" + layer_name)
                .attr("clip-path", "url(#clip)");
    }
}

function change_projection(proj_name) {
    var new_proj_name = proj_name.split('()')[0].split('.')[1];

    // Update global variables:
    proj = eval(proj_name);
    path = d3.geoPath().projection(proj).pointRadius(4);
    t = proj.translate();
    s = proj.scale();

    // Reset the projection center input :
    document.getElementById("form_projection_center").value = 0;

    // Do the reprojection :
    reproj();

    // Set or remove the clip-path according to the projection:
    handleClipPath(new_proj_name);

    // Set specifics mouse events according to the projection :
    if(new_proj_name.indexOf('Orthographic') > -1){
        var current_params = proj.rotate(),
            rotation_param = d3.select("#rotation_params");

        rotation_param.append("div").attr("class", "options_ortho").html(i18next.t("app_page.section5.projection_center_phi"))
                .insert("input")
                .attrs({type: "range", id: "form_projection_phi"})
                .attrs({value: current_params[1], min: -180, max: 180, step: 0.5})
                .on("input", function(){handle_proj_center_button([null, this.value, null])})

        rotation_param.append("div").attr("class", "options_ortho").html(i18next.t("app_page.section5.projection_center_gamma"))
                .insert("input")
                .attrs({type: "range", id: "form_projection_gamma"})
                .attrs({value: current_params[2], min: -90, max: 90, step: 0.5})
                .on("input", function(){handle_proj_center_button([null, null, this.value])});
    } else {
        d3.selectAll(".options_ortho").remove();
    }

    d3.select("svg").on("mousedown", null)
                    .on("mousemove", null)
                    .on("mouseup", null);
}

// Function making editable the text value for the projection center
// and triggering appropriate changes according to the input value
// (refuse the value or change the projection center)
function handleProjTxtChange(){
    let self = this;
    return function(){
        let prev_value = self.innerHTML;
        self.contentEditable = true;
        self.style.cursor = "text";
        setChangeListener(self, function(event){
            if(!event){ return; }
            if(event.type == "blur" || (event.type == "keyup" && event.keyCode && event.keyCode == 13)){
                event.stopPropagation();
                self.contentEditable = false;
                self.style.cursor = "pointer";
                self.innerHTML = self.innerHTML.replace("<br>", "").trim();
                console.log(self.innerHTML)
                let val = +self.innerHTML.replace(",", ".");
                if(!isNaN(val) && val <= 180 && val >= -180){
                    handle_proj_center_button([val,,]);
                    document.getElementById("form_projection_center").value = val;
                    let _old = document.getElementById("proj_center_value_txt");
                    let new_elem = _old.cloneNode(true);
                    _old.parentElement.replaceChild(new_elem, _old);
                    new_elem.onclick = handleProjTxtChange;
                } else {
                    this.innerHTML = prev_value;
                }
            }
        });
    }();
}


// Function to switch the visibility of a layer the open/closed eye button
function handle_active_layer(name){
    var fill_value, parent_div, selec, at_end;

    if(document.getElementById("info_features").className == "active"){
        displayInfoOnMove();
        at_end = true;
    }
    if(!name) {
        selec = this;
        parent_div = selec.parentElement;
        name = parent_div.parentElement.getAttribute("layer_name");
    } else {
        selec = document.querySelector("#sortable ." + name + " .active_button");
        parent_div = selec.parentElement;
    }
    let func = function() { handle_active_layer(name); };
    if(selec.id == "eye_closed"){
        fill_value = 1;
        let eye_open = make_eye_button("open");
        eye_open.onclick = func;
        parent_div.replaceChild(eye_open, selec);
    } else {
        fill_value = 0;
        let eye_closed = make_eye_button("closed");
        eye_closed.onclick = func;
        parent_div.replaceChild(eye_closed, selec);
    }
    //map.select("#"+name).style("opacity", fill_value);
    map.select("#"+name).style("visibility", fill_value == 0 ? "hidden" : "initial");
    map.selectAll(".lgdf_" + name).style("visibility", fill_value == 0 ? "hidden" : "initial");

    if(at_end){
        displayInfoOnMove();
    }
}

// Function to handle the title add and changes
function handle_title(txt){
    var title = d3.select("#map_title");
    if(title.node()){
        title.text(txt);
    } else {
        map.append("g")
             .attr("class", "legend legend_feature title")
          .insert("text")
             .attrs({id: "map_title", x: "50%", y: "8%", "alignment-baseline": "middle", "text-anchor": "middle"})
             .styles({"font-family": "Arial, Helvetica, sans-serif", "font-size": "20px", position: "absolute", color: "black"}).text(txt);
    }
}

function handle_title_properties(){
    var title = d3.select("#map_title");
    if(!title.node()){
        alert("No title no style...");
        return;
    }
    var title_props = {
        size: title.style("font-size"),
        color: title.style("fill"),
        position_x: title.attr("x"),
        position_y: title.attr("y"),
        font_family: title.style("font-family")
        };

    // Properties on the title are changed in real-time by the user then it will be rollback to original properties if Cancel is clicked
    make_confirm_dialog("", "Valid", "Cancel", "Title properties", "mapTitleitleDialogBox", 280).then(
        function(confirmed){ if(!confirmed)
            title.style("font-size", title_props.size)
                .style("fill", title_props.color)
                .style("font-family", title_props.font_family)
                .attrs({x: title_props.position_x, y: title_props.position_y});
        });
    var box_content = d3.select(".mapTitleitleDialogBox").append("div");

    box_content.append("p").html("Font-size :<br>")
        .insert("input").attrs({type: "number", min: 2, max:40, step:1, value: +title_props.size.split("px")[0]}).style("width", "50px")
        .on("change", function(){  title.style("font-size", this.value + "px");  });
    box_content.append("p").html("x position (% from the left side) :<br>")
        .insert("input").attrs({type: "number", min: 0, max:100, step:1, value: +title_props.position_x.split("%")[0]}).style("width", "50px")
        .on("change", function(){  title.attr("x", this.value + "%");  });
    box_content.append("p").html("y position (% from the top) :<br>")
        .insert("input").attrs({type: "number", min: 0, max:100, step:1, value: +title_props.position_y.split("%")[0]}).style("width", "50px")
        .on("change", function(){  title.attr("y", this.value + "%");  });
    box_content.append("p").html("Font color :<br>")
        .insert("input").attrs({type: "color", value: title_props.color})
        .on("change", function(){  title.style("fill", this.value);  });
    var font_select = box_content.append("p").html("Font family :<br>")
        .insert("select").attr("class", "params")
        .on("change", function(){  title.style("font-family", this.value); });
    available_fonts.forEach(function(font){ font_select.append("option").text(font[0]).attr("value", font[1]) });
    font_select.node().selectedIndex = available_fonts.map(d => d[1] == title_props.font_family ? "1" : "0").indexOf("1");
    // TODO : Allow the display a rectangle (resizable + selection color) under the title
    return;
}

// Function to change (one of ) the three rotations axis of a d3 projection
// and redraw all the path in respect to that
function handle_proj_center_button(param){
    let current_rotation = proj.rotate();
    if(param[0]){
        proj.rotate([param[0], current_rotation[1], current_rotation[2]]);
        map.selectAll("path").attr("d", path);
    }
    if(param[1]){
        proj.rotate([current_rotation[0], param[1] - h/2, current_rotation[2]]);
        map.selectAll("path").attr("d", path);
    }
    if(param[2]){
        proj.rotate([current_rotation[0], current_rotation[1], param[2] - h/2]);
        map.selectAll("path").attr("d", path);
    }
    reproj_symbol_layer();
}

function move_legends(new_shape){
    /*
    let legends_choro_typo = document.querySelectorAll("#legend_root"),
        legends_symbols = document.querySelectorAll("#legend_root2"),
        legends_links_discont = document.querySelectorAll("#legend_root_links");
    */
    let legends = [
        document.querySelectorAll("#legend_root"),
        document.querySelectorAll("#legend_root2"),
        document.querySelectorAll("#legend_root_links")
        ];

    let xy0_map = get_map_xy0();

    for(let j=0; j < 3; ++j){
        let legends_type = legends[j];
        for(let i=0, i_len = legends_type.length; i < i_len; ++i){
            let legend_bbox = legends_type[i].getBoundingClientRect();
            if((legend_bbox.x + legend_bbox.width / 2) > (+new_shape[0] + xy0_map.x)){
                console.log(legend_bbox)
                let current_transform = legends_type[i].getAttribute("transform");
                let regtranslate = new RegExp(/\(([^\)]+)\)/);
                let [val_x, val_y] = regtranslate.exec(current_transform)[1].split(",");
                let trans_x = legend_bbox.x +legend_bbox.width - (+new_shape[0] + xy0_map.x);
                legends_type[i].setAttribute("transform",
                    ["translate(", +val_x - trans_x, val_y, ")"].join(''));
            }
            if((legend_bbox.y + legend_bbox.height / 2) > (+new_shape[1] + xy0_map.y)){
                console.log(legend_bbox)
                let current_transform = legends_type[i].getAttribute("transform");
                let regtranslate = new RegExp(/\(([^\)]+)\)/);
                let [val_x, val_y] = regtranslate.exec(current_transform)[1].split(",");
                let trans_y = legend_bbox.y +legend_bbox.height - (+new_shape[1] + xy0_map.y);
                legends_type[i].setAttribute("transform",
                    ["translate(", val_x, +val_y - trans_y, ")"].join(''));
            }

        }
    }
}

/** Function triggered by the change of map/canvas size
* @param {Array} shape - An Array of two elements : [width, height] to use;
*                generally only used once at the time so `shape` values
*                are like [null, 750] or [800, null]
*                but also works with the 2 params together like [800, 750])
*/
function canvas_mod_size(shape){
    if(shape[0]){
        w = +shape[0];
        map.attr("width", w)
            .call(zoom_without_redraw);
        map_div.style("width", w + "px");
        if(w + 360 + 30 < window.innerWidth){
            document.querySelector(".light-menu").style.right = '-30px';
        } else {
            document.querySelector(".light-menu").style.right = '0px';
        }
    }
    if(shape[1]){
        h = +shape[1];
        map.attr("height", h)
            .call(zoom_without_redraw);
        map_div.style("height", h + "px");
    }
    move_legends([w, h]);
}

function export_compo_svg(){
    let targetSvg = document.getElementById("svg_map"),
        serializer = new XMLSerializer(),
        source = serializer.serializeToString(targetSvg);

    if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
        source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
    }
    if(!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)){
        source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
    }

    source = ['<?xml version="1.0" standalone="no"?>\r\n', source].join('');

    let url = "data:image/svg+xml;charset=utf-8,"+encodeURIComponent(source),
        dl_link = document.createElement("a");

    dl_link.download = "export.svg";
    dl_link.href = url;
    dl_link.dataset.downloadurl = ["image/svg", dl_link.download, dl_link.href].join(':');
    document.body.appendChild(dl_link);
    dl_link.click();
    dl_link.remove();

}

function export_compo_png(){
    // Todo : ask for output format (svg / png) before conversion / ! \
    var targetCanvas = d3.select("body").append("canvas").attrs({id: "canvas_map_export", height: h, width: w}).node(),
        targetSVG = document.querySelector("#svg_map"),
        svg_xml = (new XMLSerializer()).serializeToString(targetSVG),
        ctx = targetCanvas.getContext('2d'),
        mime_type = "image/png",
        img = new Image();

    img.src = "data:image/svg+xml;base64," + btoa(svg_xml);
    img.onload = function() {
        ctx.drawImage(img, 0, 0);
        var imgUrl = targetCanvas.toDataURL(mime_type),
            dl_link = document.createElement("a");

        dl_link.download = "export.png";
        dl_link.href = imgUrl;
        dl_link.dataset.downloadurl = [mime_type, dl_link.download, dl_link.href].join(':');
        document.body.appendChild(dl_link);
        dl_link.click();
        dl_link.remove();
        targetCanvas.remove();
    }
}

function apply_user_preferences(json_pref){
    let preferences = JSON.parse(json_pref),
        map_config = preferences.map_config,
        layers = preferences.layers;

    var func_name_corresp = new Map([
        ["Links", "flow"], ["PropSymbolsChoro", "choroprop"],
        ["PropSymbols", "prop"], ["Stewart", "smooth"], ["Gridded", "grid"],
        ["DiscLayer", "discont"], ["Choropleth", "choro"], ["Categorical", "typo"]
    ]);

    // Update some global variables with the readed values in order to retrieve
    // the same map size / orientation / zoom / etc ...
    w = +map_config.div_width;
    h = +map_config.div_height;
    canvas_mod_size([w, h]);
    document.getElementById("input-width").value = w;
    document.getElementById("input-height").value = h;
    current_proj_name = map_config.projection;
    proj = eval(available_projections.get(current_proj_name));
    s = map_config.projection_scale;
    t = map_config.projection_translate;
    proj.scale(s).translate(t).rotate(map_config.projection_rotation);
    path = d3.geoPath().projection(proj).pointRadius(4);
    map.selectAll("path").attr("d", path);

    for(let i = map_config.n_layers - 1; i > -1; --i){
        let layer_name = layers[i].layer_name,
            symbol,
            layer_selec;

        let fill_opacity = layers[i].fill_opacity,
            stroke_opacity = layers[i].stroke_opacity;

        if(layers[i].topo_geom && layer_name != "Sphere" && layer_name != "Simplified_land_polygons"){
            let tmp = {skip_alert: true};
            if(layers[i].targeted){
                tmp['target_layer_on_add'] = true;
            } else if(layers[i].renderer){
                tmp['func_name'] = func_name_corresp.get(layers[i].renderer)
                tmp['result_layer_on_add'] = true;
            }
            tmp['choosed_name'] = layer_name;
            handle_reload_TopoJSON(layers[i].topo_geom, tmp).then(function(n_layer_name){
                console.log([layer_name, n_layer_name])
                layer_name = n_layer_name;
                if(layers[i].renderer){
                    current_layers[layer_name].renderer = layers[i].renderer;
                }

                symbol = "path";
                layer_selec = map.select("#" + layer_name);

                current_layers[layer_name].rendered_field = layers[i].rendered_field;
                current_layers[layer_name]['stroke-width-const'] = layers[i]['stroke-width-const'];
                current_layers[layer_name].fixed_stroke = layers[i].fixed_stroke;
                if(layers[i].ref_layer_name)
                    current_layers[layer_name].ref_layer_name = layers[i].ref_layer_name;
                if(layers[i].size)
                    current_layers[layer_name].size = layers[i].size;
                if(layers[i].colors_breaks)
                    current_layers[layer_name].colors_breaks = JSON.parse(layers[i].colors_breaks);
                if(layers[i].fill_color)
                    current_layers[layer_name].fill_color = layers[i].fill_color;
                console.log(layers[i])
                if(layers[i].renderer){
                    if(layers[i].renderer == "Choropleth"
                        || layers[i].renderer == "Stewart"
                        || layers[i].renderer == "Gridded"){
                        layer_selec.selectAll("path")
                                .style("fill", (d,j) => layers[i].color_by_id[j])
                    } else if (layers[i].renderer == "Links"){
                        current_layers[layer_name].linksbyId = layers[i].linksbyId;
                        current_layers[layer_name].min_display = layers[i].min_display;
                    } else if (layers[i].renderer == "DiscLayer"){
                        current_layers[layer_name].result = new Map(layers[i].result);
                        layer_selec.selectAll("path").style("stroke-width", (d,i) => { return current_layers[layer_name].result.get(d.id); });
                    }
                } else if(layers[i].fill_color.random) {
                        layer_selec
                            .selectAll(symbol)
                            .style("fill", () => Colors.names[Colors.random()]);
                }
                layer_selec.selectAll(symbol)
                        .style("fill-opacity", fill_opacity)
                        .style("stroke-opacity", stroke_opacity)
            });
        } else if (layer_name == "Sphere" || layer_name == "Simplified_land_polygons"){
            add_layout_feature(layer_name);
        } else if (layers[i].renderer && layers[i].renderer.startsWith("PropSymbol")){
            let layer_to_append = map.append("g").attr("id", layer_name).attr("class", "result_layer layer");
            let zs = map_config.zoom_scale;
            let full_params = JSON.parse(layers[i].features_order);
            let n_ft = full_params.length;
            symbol = layers[i].symbol;

            current_layers[layer_name] = {
                renderer: layers[i].renderer,
                rendered_field:layers[i].rendered_field,
                'stroke-width-const': layers[i]['stroke-width-const'],
                fixed_stroke: layers[i].fixed_stroke,
                size: layers[i].size,
                ref_layer_name: layers[i].ref_layer_name,
                fill_color: layers[i].fill_color,
                features_order: full_params,
                symbol: symbol,
                n_features: n_ft,
                }

            let ref_size = current_layers[layer_name].size[0],
                max_size = current_layers[layer_name].size[1];

            if(layers[i].colors_breaks)
                current_layers[layer_name].colors_breaks = JSON.parse(layers[i].colors_breaks);

            if(symbol == "circle"){
                for(let ii = 0; ii < n_ft; ii++){
                    let params = full_params[ii];
                    layer_to_append.append('circle')
                        .attr('cx', params[2][0])
                        .attr("cy", params[2][1])
                        .attr("r", ref_size / zs + params[1])
                        .attr("id", ["PropSymbol_", ii , " feature_", params[0]].join(''))
                        .style("fill", params[3])
                        .style("stroke", "black")
                        .style("stroke-width", 1 / zs);
                }
            } else if(symbol == "rect"){
                for(let ii = 0; ii < n_ft; ii++){
                    let params = full_params[ii],
                        size = ref_size / zs + params[1];

                    layer_to_append.append('rect')
                        .attr('x', params[2][0] - size/2)
                        .attr("y", params[2][1] - size/2)
                        .attr("height", size)
                        .attr("width", size)
                        .attr("id", ["PropSymbol_", ii , " feature_", params[0]].join(''))
                        .style("fill", params[3])
                        .style("stroke", "black")
                        .style("stroke-width", 1 / zs);
                };
            }
            layer_selec = map.select("#"+layer_name);
            layer_selec.selectAll(symbol)
                    .style("fill-opacity", fill_opacity)
                    .style("stroke-opacity", stroke_opacity);
            create_li_layer_elem(layer_name, n_ft, ["Point", "prop"], "result");
        } else if (layers[i].renderer && layers[i].renderer.startsWith("Label")){
            let layer_to_append = map.append("g").attr("id", layer_name)
                                        .attr("class", "result_layer layer");
            let nb_ft = layers[i].n_features;
            let symbols_map = new Map(layers[i].symbols_map);
            current_layers[layer_name] = {
                n_features: nb_ft,
                renderer: "TypoSymbols",
                symbols_map: symbols_map,
                symbol: "image",
                renderer_field: layers[i].rendered_field,
                is_result: true,
                default_size: undefined
            }

            let current_state = layers[i].current_state;
            result_data[layer_name] = [];
            for(let j = 0; j < nb_ft; j++){
                result_data[layer_name].push(current_state[j].data);
            }

            layer_to_append.selectAll('image')
                .data(result_data[layer_name]).enter()
                .insert("image")
                .attr("x", (d,i) => current_state[i].pos[0])
                .attr("y", (d,i) => current_state[i].pos[1])
                .attr("width", (d,i) => current_state[i].size)
                .attr("height", (d,i) => current_state[i].size)
                .attr("xlink:href", (d,i) => symbols_map.get(d.Symbol_field)[0])
                .style("display", (d,i) => current_state[i].display)
                .on("mouseover", function(){ this.style.cursor = "pointer";})
                .on("mouseout", function(){ this.style.cursor = "initial";})
                /* .on("dblclick", function(){
                    context_menu.showMenu(d3.event, document.querySelector("body"), getItems(this));
                    })
                .on("contextmenu", function(){
                    context_menu.showMenu(d3.event, document.querySelector("body"), getItems(this));
                    }) */
                .call(drag_elem_geo);
            create_li_layer_elem(layer_name, nb_ft, ["Point", "symbol"], "result");
        } else if (layers[i].renderer && layers[i].renderer.startsWith("Choropleth")){
            let rendering_params = {
                    "nb_class": "",
                    "type":"",
                    "schema": layers[i].options_disc.schema,
                    "no_data": layers[i].options_disc.no_data,
                    "colors": layers[i].options_disc.colors,
                    "colorsByFeature": layers[i].color_by_id,
                    "renderer": "Choropleth",
                    "rendered_field": layers[i].rendered_field,
                    "new_name": layer_name
                };
            render_choro(layers[i].ref_layer_name, rendering_params);
        } else {
            null;
        }

        if(layers[i].is_result && map_config.displayed_legend)
            handle_legend(layer_name);
    }
    let _zoom = svg_map.__zoom;
    _zoom.k = map_config.zoom_scale;
    _zoom.x = map_config.zoom_translate[0];
    _zoom.y = map_config.zoom_translate[1];
    zoom_without_redraw();

    if(map_config.title){
        let title = document.getElementById("map_title");
        if(title){
            title.textContent = map_config.title.content;
            title.setAttribute("x", map_config.title.x);
            title.setAttribute("y", map_config.title.y);
            title.setAttribute("style", map_config.title.style);
        } else {
            title = map.append("g")
                     .attr("class", "legend_feature title")
                  .insert("text")
                     .attrs({id: "map_title", x: map_config.title.x, y: map_config.title.y, "alignment-baseline": "middle", "text-anchor": "middle"})
                     .text(map_config.title.content);
            title.node().setAttribute("style", map_config.title.style);
        }
    }
}

function handle_export(){
    var dialogBox = document.querySelector(".exportDialogBox");
    if(dialogBox){
        dialogBox.parentElement.remove();
        return;
    }

    d3.select("body").append("div")
        .attrs({"id": "dialog", "class": "exportDialogBox"})
        .attr("title", i18next.t("app_page.export_box.title")).html("");

    dialogBox = $(".exportDialogBox");
    var box_content = d3.select(".exportDialogBox").append("div");

    box_content.append("button")
        .attr("class", "button_st4")
        .html(i18next.t("app_page.export_box.png"))
        .on("click", function(){
            dialogBox.dialog("destroy").remove();
            export_compo_png();
        });

    box_content.append("button")
        .attr("class", "button_st4")
        .html(i18next.t("app_page.export_box.svg"))
        .on("click", function(){
            dialogBox.dialog("destroy").remove();
            export_compo_svg();
        });

    box_content.append("button")
        .attr("class", "button_st4")
        .html(i18next.t("app_page.export_box.geo"))
        .on("click", function(){
            dialogBox.dialog("destroy").remove();
            make_export_layer_box();
        });

    dialogBox.dialog({
        position: { my: "center", at: "top" },
        modal: false,
        close: function(event, ui){ $(this).dialog("destroy").remove(); }
      });
}

function make_export_layer_box(){
    d3.select("body").append("div")
        .attrs({id: "dialogGeoExport", class: "exportGeoDialogBox", title: i18next.t("app_page.export_box.geo_title_box")})
        .style("font-size", "0.6em")
        .html("");

    let dialogBox = $("#dialogGeoExport"),
        box_content = d3.select("#dialogGeoExport").append("div");

    dialogBox.dialog({
        position: { my: "center", at: "top" },
        width: 400,
        modal: false,
        close: function(event, ui){ $(this).dialog("destroy").remove(); }
      });

    let layer_names = Object.getOwnPropertyNames(current_layers).filter(name => {
        if(sample_no_values.has(name))
            return 0;
        else if(current_layers[name].renderer
                && (current_layers[name].renderer.indexOf("PropSymbols") > -1
                    || current_layers[name].renderer.indexOf("Dorling") > -1))
            return 0;
        return 1;
    });

    box_content.append("h3").html(i18next.t("app_page.export_box.options"));

    let selec_layer = box_content.append("p").html(i18next.t("app_page.export_box.option_layer"))
             .insert("select").attr("id", "layer_to_export");

    let selec_type = box_content.append("p").html(i18next.t("app_page.export_box.option_datatype"))
             .insert("select").attr("id", "datatype_to_use");

    let selec_projection = box_content.append("p").html(i18next.t("app_page.export_box.option_projection"))
             .insert("select").attr("id", "projection_to_use");

    let proj4_input = box_content.append("input")
                                .attr("id", "proj4str")
                                .style("display", "none")
                                .style("width", "200px");

    layer_names.forEach( name => {
        selec_layer.append("option").attr("value", name).text(name);
    });

    ["GeoJSON", "TopoJSON", "ESRI Shapefile", "GML", "KML"].forEach( name => {
        selec_type.append("option").attr("value", name).text(name);
    });

    [["Geographic coordinates / WGS84 (EPSG:4326)", "epsg:4326"],
     ["Web-mercator / WGS84 (EPSG:3857)", "epsg:3857"],
     ["LAEA Europe / ETRS89 (EPSG:3035)", "epsg:3035"],
     ["USA Albers Equal Area / NAD83", "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs"],
     ["British National Grid / OSGB36 (EPSG:27700)", "epsg:27700"],
     ["Lambert-93 / RGF93-GRS80 (EPSG:2154)", "epsg:2154"],
     ["Eckert IV / WGS84", "+proj=eck4 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs "],
     ["Enter any valid Proj.4 string...", "proj4string"]].forEach(projection => {
        selec_projection.append("option").attr("value", projection[1]).text(projection[0]);
    });

    selec_type.on("change", function(){
        if(this.value == "TopoJSON" || this.value == "KML"){
            selec_projection.node().options.selectedIndex = 0;
            selec_projection.attr("disabled", true);
        } else {
            selec_projection.attr("disabled", null);
        }
    });

    selec_projection.on("change", function(){
        if(this.value == "proj4string")
            proj4_input.style("display", "initial");
        else
            proj4_input.style("display", "none");
    });

    let extensions = new Map([
        ["GeoJSON", "geojson"],
        ["TopoJSON", "topojson"],
        ["ESRI Shapefile", "zip"],
        ["GML", "zip"],
        ["KML", "kml"]]);

    box_content.append("p").append("button")
            .attr("class", "button_st4")
            .html("Export")
            .on("click", function(){
                let layer = selec_layer.node().value,
                    type = selec_type.node().value,
                    projec = selec_projection.node().value;
                let formToSend = new FormData();
                formToSend.append("layer", layer);
                formToSend.append("layer_name", current_layers[layer].key_name);
                formToSend.append("format", type);
                if(projec == "proj4string")
                    formToSend.append("projection", JSON.stringify({"proj4string" : proj4_input.node().value}));
                else
                    formToSend.append("projection", JSON.stringify({"name" : projec}));
                $.ajax({
                    processData: false,
                    contentType: false,
                    url: '/get_layer2',
                    data: formToSend,
                    type: 'POST',
                    error: function(error) { console.log(error); },
                    success: function(data, code, obj){
                        if(data.indexOf("Error:") == 0){
                            swal("Oops...", i18next.t("app_page.common.error_msg", {msg: data.substring(6, data.length)}), "error");
                            return;
                        }
                        let ext = extensions.get(type),
                            dataStr;

                        if(ext.indexOf("json") > -1)
                            dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(data);
                        else if (ext.indexOf("kml") > -1)
                            dataStr = "data:text/xml;charset=utf-8," + encodeURIComponent(data);
                        else
                            dataStr = "data:application/zip;base64," + data;

                        let dlAnchorElem = document.getElementById('downloadAnchorElem');
                        dlAnchorElem.setAttribute("href", dataStr);
                        dlAnchorElem.setAttribute("download", [layer, ext].join('.'));
                        dlAnchorElem.click();
                    }
                });
                dialogBox.dialog("destroy").remove();
            });
}

// Only ask for confirmation before leaving page if things have been done
// (layer added, etc..)
window.addEventListener("beforeunload", event => {
    get_map_template().then(function(json_params){
        window.localStorage.removeItem("noname_app_project");
        window.localStorage.setItem("noname_map_project", json_params);
    });
    event.returnValue = (targeted_layer_added || Object.getOwnPropertyNames(result_data).length > 0) ? "Confirm exit" : "";
});

// Remove some layers from the server when user leave the page
// (ie. result layers are removed but targeted layer and layout layers stay
// in cache as they have more chance to be added again)
window.addEventListener("unload", function(){

    let layer_names = Object.getOwnPropertyNames(current_layers).filter(name => {
        if(sample_no_values.has(name) || !(current_layers[name].hasOwnProperty("key_name")))
            return 0;
        else if(current_layers[name].targeted)
            return 0;
        else if(current_layers[name].renderer
                && (current_layers[name].renderer.indexOf("PropSymbols") > -1
                    || current_layers[name].renderer.indexOf("Dorling") > -1
                    || current_layers[name].renderer.indexOf("Choropleth") > -1
                    || current_layers[name].renderer.indexOf("Categorical") > -1))
            return 0;
        return 1;
    });
    if(layer_names.length){
        let formToSend = new FormData();
        layer_names.forEach(function(name){
            formToSend.append("layer_name", current_layers[name].key_name);
        });
        navigator.sendBeacon("/layers/delete", formToSend);
    }
}, false);

function get_zoom_param(scale){
    let transform = map.select(".layer").attr("transform"),
        zoom_scale = +new RegExp(/scale\(([^)]+)\)/).exec(transform)[1].split(',')[0];
    if(scale) return zoom_scale;
    else {
        let zoom_translate = new RegExp(/translate\(([^)]+)\)/).exec(transform)[1].split(',').map(f => +f);
        return {scale: zoom_scale, translate: zoom_translate}
    }
}

</script>
</body>
</html>
